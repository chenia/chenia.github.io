<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C#,">





  <link rel="alternate" href="/atom.xml" title="Chenia's Blog" type="application/atom+xml">






<meta name="description" content="33、常量\枚举\结构定义一个常量 ：const 类型 常量名 = 常量值；确定数量、确定值的几个取值可以使用枚举语法：[public] enum 枚举名{    值1；    值2；    …….} 注意：枚举名的命名规范必须符合 Pascal的命名规范定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举 enum Gender{male,f">
<meta name="keywords" content="C#">
<meta property="og:type" content="article">
<meta property="og:title" content="C#学习阶段二">
<meta property="og:url" content="http://yoursite.com/2019/09/24/C#学习阶段二/index.html">
<meta property="og:site_name" content="Chenia&#39;s Blog">
<meta property="og:description" content="33、常量\枚举\结构定义一个常量 ：const 类型 常量名 = 常量值；确定数量、确定值的几个取值可以使用枚举语法：[public] enum 枚举名{    值1；    值2；    …….} 注意：枚举名的命名规范必须符合 Pascal的命名规范定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举 enum Gender{male,f">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-24T06:03:16.691Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C#学习阶段二">
<meta name="twitter:description" content="33、常量\枚举\结构定义一个常量 ：const 类型 常量名 = 常量值；确定数量、确定值的几个取值可以使用枚举语法：[public] enum 枚举名{    值1；    值2；    …….} 注意：枚举名的命名规范必须符合 Pascal的命名规范定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举 enum Gender{male,f">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/24/C#学习阶段二/">





  <title>C#学习阶段二 | Chenia's Blog</title>
  








</head>
<script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Tomorrow is another chance</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/C#学习阶段二/">
   
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenia">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenia's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C#学习阶段二</h1>
        

        <div class="post-meta">
		  
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T13:33:18+08:00">
                2019-09-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-24T14:03:16+08:00">
                2019-09-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>33、常量\枚举\结构<br>定义一个常量 ：const 类型 常量名 = 常量值；<br>确定数量、确定值的几个取值可以使用枚举<br>语法：<br>[public] enum 枚举名<br>{<br>    值1；<br>    值2；<br>    …….<br>}</p>
<p>注意：枚举名的命名规范必须符合 Pascal的命名规范<br>定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举</p>
<p>enum Gender{male,female}<br> enum Status{Online,offline,hidden};<br>枚举的用法：Status s  s =  Status.online;<br>和字符串比起来，用枚举的好处就是限定了变量的取值范围</p>
<p>34、枚举类型与int类型和string类型之间的转换<br>枚举类型和int类型相互兼容，所以两种类型可以通过强制类型转换的语法相互转换，枚举类型的默认值是从0开始的。</p>
<p>35、结构<br>作用：可以一次性声明不同类型的变量<br>语法：<br>[public] struct 结构名<br>{<br>    结构成员;<br>}<br>注意：结构名的命名规范必须符合 Pascal的命名规范<br>      写在命名空间下<br>结构体内的不叫变量，叫字段，字段的命名习惯在前面加下划线</p>
<p>36、数组<br>语法：<br>数组类型[] 数组名 = new 数组类型[数组长度];<br>注意：数组的长度一旦声明了，就不能再改变了<br>数组里存储的只能是同一种数据类型</p>
<p>声明数组的4种方式：<br>int[] l1 = new int[4];//只定义了一个数组，未赋<br>int[] l2 = { 8, 2, 1, 4, 7, 6, 5, 9, 3};<br>int[] l3 = new int[4] { 1, 2, 3, 4 };<br>int[] l4 = new int[] { 1, 2, 3, 4 };</p>
<p>37、变量的作用域<br>一般变量的作用范围为定义时所在的大括号到结束时的大括号的范围内<br>局部变量<br>全局变量：作用范围为全类，必须为static，且在class后面定义；</p>
<p>38、out参数<br>Out参数可以帮助我们在一个方法中返回多个值，不限类型<br>注意：out参数必须在方法内赋值</p>
<p>调用者内必须传入：out  变量名<br>被调用者内定义out 数据类型 变量名<br>语法：<br>Int s;<br>调用ze(out s)<br>被调用ze(out int s){….}<br>或者<br>调用 ze(out int s)<br>被调用ze(out int s){….}</p>
<p>39、ref 参数<br>Ref参数是将一个变量以参数的形式带到一个方法中进行改变，改变完成后，再将改变后的值带出来。<br>注意：ref参数在方法外必须为其赋值</p>
<p>Int s = 0;<br>调用ze(ref s)<br>被调用ze(ref int s){….}</p>
<p>40、方法的重载<br>方法的重载指的是方法名称相同，但是参数不同。<br>参数不同：<br>1）、如果参数的个数相同，那么参数的类型就不能相同<br>2）、如果参数的类型相同，那么参数的个数就不能相同</p>
<p>注意：方法的重载和返回值无关</p>
<p>41、params 参数<br>可变参数数组<br>作用：将某些值默认加入到数组中<br>注意：这些值的类型必须相同<br>      被params修饰的形参只能做最后一个形参</p>
<p>42、面向对象<br>面向对象三大特征：继承 封装 多态<br>类是一个抽象的<br>类的语法：<br>[访问修饰符]  class  类名<br>{<br>    类的成员; //字段、属性、方法</p>
<p>}<br>访问修饰符 public<br>类名：pascal 要求每个首字母大写</p>
<p>写好一个类之后，需要创建这个类的对象，我们管创建这个类的对象的过程称之为类的实例化   使用关键字new<br>注意：类是不占内存的，对象占内存<br>43、this<br>This代表当前类的  对象 </p>
<p>44、类成员<br>类的成员可以有：<br>字段：存储数据  一般为私有的<br>属性：保护字段<br>方法：对象行为<br>构造函数：初始化对象</p>
<p>45、修饰符  private<br>类中的成员如果不加访问修饰符，默认为private<br>Private表示私有的，只能在当前类的内部访问，出了这个类之后，就访问不到了</p>
<p>46、属性<br>Fields      字段<br>Methods   方法<br>Properties  属性<br>属性是为了保护字段不被随意的修改<br>字段的属性本质上是由get/set方法构成  属性的本质就是方法<br>给字段赋值时，调用set方法<br>取值时，调用get方法</p>
<p>String   _name<br>Public string Name<br>{<br>    Get { return _name;}<br>    Set{ _name = value;}<br>}<br>注意：字段是：_name   属性是：Name<br>应该给每个字段都配上属性</p>
<p>三种属性：<br>既有get方法也有set方法，称之为可读可写属性<br>只有get方法没有set方法，称之为只读属性<br>只有set方法没有get方法，称之为只写属性</p>
<p>47、构造函数（构造方法）<br>构造函数的作用是对对象进行初始化<br>构造函数本质就是一个函数，特殊的函数<br>语法：<br>Public 构造函数名()<br>{<br>    代码;<br>}<br>1、    public必须要<br>2、    没有返回值void都不需要<br>3、    构造函数的名称必须与类名相同</p>
<p>调用构造函数<br>New的作用：<br>1）    在堆内存中开辟空间<br>2）    在开辟的堆空间中创建对象<br>3）    调用对象的构造函数</p>
<p>特点：<br>1）    可以重载<br>2）    类中默认会有一个无参数的构造函数，当重写了构造函数后，默认的构造函数失效</p>
<p>48、值类型和引用类型<br>值类型：int double char bool decimal struct enum<br>引用类型：string 数组 自定义类<br>存储数据的地方：堆 栈 静态存储区域</p>
<p>值类型：值类型的值存储在栈中<br>引用类型：引用类型的值存储在堆中</p>
<p>49、静态和非静态的区别<br>区别：有没有static<br>在非静态类中，可以有静态成员，也可以有非静态成员<br>在非静态方法中，可以访问静态成员，也可以访问非静态成员<br>在静态方法中，只允许访问静态成员<br>在静态类中，不能出现非静态成员，只能有静态成员<br>在调用上的区别：<br>1）    在调用实例成员时，需要使用对象去调用<br>2）    在调用静态成员时，必须使用类名.静态成员</p>
<p>静态类不允许创建对象的，静态类的成员，全部用类名.静态成员</p>
<p>什么时候用静态类？什么时候用非静态类？<br>如果类属于工具类（非常常用），可以写成静态类</p>
<p>类不占内存，但静态类占用内存，占用静态存储区域，静态类的资源共享<br>静态类应该越少越好<br>静态类释放资源时，必须等待所有的程序结束的时候才能被释放</p>
<p>50、垃圾回收期和析构函数<br>GC：gargbage collection<br>当程序结束后，GC会扫描整个内存，如果有空间没有被指向，则把该空间销毁<br>析构函数是C语言里回收垃圾的</p>
<p>51、字符串<br>字符串具有不可变性：当给字符串重新赋值时，其实是在内存中重新开辟一块空间存储值。<br>由于字符串的不可变性，当需要给一个字符串进行大量的拼接、赋值等操作时，会产生大量的内存垃圾；可以使用StringBuilder</p>
<p>一切类型都可以调用ToString()方法转换成字符串类型</p>
<p>字符串的各种方法：<br>ToCharArrray()：将字符串转换成char类型的数组<br>New string(char[]  chs)：将一个字符数组转换成一个字符串<br>Length：查看字符串的长度<br>ToUpper：转换成大写<br>ToLower：转换成小写<br>Equals(“要比较的字符串”,StringComparison.OrdinalIgnoreCase)：比较字符串是否相同，忽略大小写;<br>Split：分割字符串，返回一个字符串的数组<br>Split(char[]  ch,StringSplitOptions.RemoveEmptyEntries ) ：ch是分割的内容，后面是分割后替代的内容<br>Replace：替代字符串<br>Replace(string oldValue,string newValue)：将字符串中出现的oldValue的地方替换为newValue<br>SubString：截取字符串<br>Substring(int startindex)：从位置startIndex开始截取到最后的子字符串<br>SubString(int startindex,int length)：从位置startINdex开始截取长度为length的子字符串，如果长度不够则会报错；<br>Contains(string value)：判断字符串中是否含有子串value<br>StartsWith(string value)：判断字符串是否以子串value开始<br>EndsWith(string value)：判断字符串是否以子串value结束<br>IndexOf(string value)：子串value第一次出现的位置<br>IndexOf(strinf value,int startIndex)：例如：value第一次出现的位置是1，找第二个value植时，startIndex需要加1，若找不到时，会返回-1<br>LastIndexOf(string value)：<br>Trim：去掉字符串中的空格<br>Trim()：去掉两边的空格<br>TrimEnd()：去掉后面的空格<br>TrimStart()：去掉前面的空格<br>Join：连接</p>
<p>52、继承<br>语法： 用 : 要继承的类<br>为什么要继承：<br>将一些类中共同具有的属性和方法单独拿出来封装成一个父类。<br>面向对象的三大特征：封装 继承 多态</p>
<p>自动属性：不需要写字段的<br>Public string Name<br>{<br>    get;<br>set;<br>}</p>
<p>如果一个类继承了另一个类，则称这个类为子类（派生类），被继承的类为父类（基类）。</p>
<p>子类继承父类：<br>子类继承属性和方法<br>子类不能继承私有字段，不能继承构造函数<br>注意：子类并没有继承父类的构造函数，但是会默认的调用父类的无参的构造函数；当在父类中重写了构造函数后，默认的无参构造函数就不存在了，此时，子类就无法调用父类的无参构造函数<br>解决办法：<br>1）    在子类中重写一个无参的构造函数<br>2）    让子类调用父类有参的构造函数，使用关键字 :base</p>
<p>继承的两个特性：<br>1）    单根性 一个子类只有一个父类（一个儿子只能有一个爸爸）<br>2）    传递性 子类可以继承父类的父类</p>
<p>Object类是一切类型的基类</p>
<p>53、new 关键字<br>如果子类中的方法和父类重名了，子类若想继续使用该方法，可以在子类的方法内增加关键字 new 将相同名称的父类的方法隐藏掉，<br>Public new void 相同名称的方法名(){….  }</p>
<p>54、this 关键字<br>作用：代表当前类的对象<br>      显示的调度自己的构造函数</p>
<p>55、里氏转换<br>1）子类对象可以赋值给父类（如果有一个地方需要一个父类作为参数，可以用子类代替）<br>2）如果这个父类中装的是子类对象，那么可以将这个父类强转为对应的子类对象<br>子类：student<br>父类：person<br>Students s = new Student();<br>Person p = s;<br>Student ss = (Student)p;</p>
<p>56、as/is 关键字<br>is：判断能否进行类型转换，如果转换成功，返回true，转换失败，返回false<br>as: 判断能否进行类型转换，如果转换成功，返回对应的对象，如果转换失败，返回一个null</p>
<p>57、集合    using System.Collections<br>ArrayList<br>Hashtable<br>List<t><br>Dictionary<t,t></t,t></t></p>
<p>数组的长度不可改变<br>集合的长度可以任意改变</p>
<p>ArrayList：</p>
<p>方法：<br>添加：<br>Add(value)：添加单个元素<br>AddRange(value)：添加集合或者数组<br>删除：<br>Clear()：删除集合中所有的所有<br>Remove(value)：根据值删除单个元素，如果没有value，程序不报错<br>RemoveAt(index)：根据索引删除单个元素<br>RemoveRange(startIndex,endIndex)：删除指定范围内的元素<br>插入：<br>Insert(Index,value)：在指定的索引上添加值<br>InsertRange(Index,value)：在指定的索引上添加数组或者集合<br>其他：<br>Contains()：判断是否包含<br>Sort()：排序<br>Count：获得长度   数组是Length<br>Max()：找出最大值<br>Min()：找出最小值<br>AVG()：求平均值</p>
<p>58、集合的长度<br>Count：集合中实际包含的长度<br>Capcity：集合可以包含的长度</p>
<p>当向集合中添加1个元素时，集合的capcity=4；<br>当添加的元素超过4个时，集合的capcity=12；</p>
<p>59、Hashtable<br>可以称为 字典，存储的是键值对<br>在键值对集合中，键一定是唯一的，不能重复，值可以重复</p>
<p>方法：<br>Add(key,value)：添加键值对<br>foreach：循环集合中的元素<br>foreach(var  item  in  collection)<br>keys：获得集合中的键值对    集合[key]=value<br>clear()：清除集合中键值对<br>contains()：是否包含元素<br>containsKey(key)<br>containsValue(value)<br>remove(key)：根据键移除元素</p>
<p>60、var 推断类型<br>C#是一门强类型语言，每一种变量必须有一个明确的定义<br>JavaScript是一门弱类型语言</p>
<p>GetType()：获得变量的数据类型</p>
<p>var 可以通过变量的推断变量的类型</p>
<p>61、File类 静态类    在System.IO命名空间下<br>静态类不能创建对象<br>静态类的成员都是静态成员，可以直接类名.成员调用<br>File类：操作文件的类（不是文件夹）</p>
<p>OpenFileDialog ofd = new OpenFileDialog();</p>
<p>File.方法：<br>Exits(文件地址)：判断文件是否存在<br>Create(文件地址)：创建文件<br>Delete(文件地址)：删除文件<br>Copy(源文件地址,复制文件地址)：复制文件<br>Move(源文件地址,复制文件地址)：移动文件<br>读取文件：<br>1）String[]  str  =  ReadAllLines(文件地址,读取文件的编码方式)：一行一行读取文件，返回值为字符串数组<br>Encoding.Default：默认方式<br>Encoding.UTF-8<br>Encoding.Unicode</p>
<p>2）String str = ReadAllText(文件地址,读取文件的编码方式)：读取整个文本，返回值为字符串<br>ReadAllLines()和ReadAllText()只能读取txt文件</p>
<p>3）    byte[]  buffer  =  ReadAllBytes(文件地址)<br>buffer里存的都是数字，需要将buffer转换成字符串，使用Enconding.Default.GetString(buffer);<br>string  str  = Enconding.Default.GetString(buffer);<br>ReadAllBytes()可以操作任何格式的文件</p>
<p>Enconding.Default.GetString();<br>Enconding.UTF-8.GetString();<br>Enconding.Unicode.GetString();<br>Enconding.GetEncoding(“GBK”).GetString();</p>
<p>1024byte=1kb<br>1024kb=1M</p>
<p>62、导入命名空间的快捷方式<br>1）使用快捷键 alt+shift+F10<br>2）使用鼠标的方式</p>
<p>63、编码<br>编码：<br>乱码的原因：<br>保持文件所采取的编码格式与打开文件的编码格式不一致</p>
<p>文本文件编码，文本文件有不同的存储方式，将字符串以什么样的形式保存为二进制，这个就是编码，UTF-8、ASCII、Unicode等，如果出现乱码一般就是编码的问题，文本文件相关的函数一般都有Encoding类型的参数，取得编码的方式：Encoding.Default、Encoding.UTF8、Encoding.GetEncoding(“GBK”)<br>输出Encoding.GetEncodings()，所有的编码</p>
<p>常用的静态方法：<br>void  AppendAllText(string path,string contents,编码方式)：将文本contents附加到文件path中<br>bool  Exists(string path)：判断文件path是否存在<br>string[]  ReadAllLines(string path)：读取文本文件到字符串数组中<br>string  ReadAllText(string path)：读取文本文件到字符串中<br>void  WriteAllText(string path,string contents)：将文本contents保持到文件path中，会覆盖旧内容<br>void  WriteAllLines(string path,string[] contents)：将字符串数组逐行保存到文件path中，会覆盖旧内容</p>
<p>64、Directory类<br>Directory类：操作文件夹<br>Directory类 静态类  在System.IO命名空间下<br>静态类不能创建对象<br>静态类的成员全部为静态成员，直接类名调用</p>
<p>CreateDirectory(string path)：创建文件夹<br>Delete(string path,true)：删除文件夹<br>Move(string oldpath,string newpath)：剪切文件夹<br>String[]  path  =  GetFiles(string path,匹配项)：获得文件夹下与匹配项相同的所有文件</p>
<p>65、path类 静态类  在System.IO命名空间下<br>path类：操作路径<br>GetFileName()：获得文件名    ——-1.txt<br>GetFileNameWithoutExtension()：获得除去拓展名的文件名  ———1<br>GetExtension()：获得文件的拓展名<br>GetDirectoryName()：获取文件夹名<br>GetFullPath()：获取绝对路径<br>Combine(params,path)：连接路径</p>
<p>66、文件流<br>File类的弊端：读写速度太慢，只能读写小文件，因为它是将文件一次性读写出来的<br>文件流读写文件时，每次只占用规定的缓存区大小<br>文件流：FileStream、StreamReader、StreamWriter<br>FileStream：用来操作字节的<br>    方法：Read()、Write()<br>StreamReader 、StreamWriter：用来操作字符的<br>方法：Read()、ReadLine()….</p>
<p>67、FileStream的使用<br>FlieStream用来操作字节<br>创建FileStream对象：<br>FileStream fs = new FileStream(path,opreateFile,opreateData);<br>第一个参数path：表示要操作的文件的路径<br>第二个参数opreateFile：表示对文件进行怎么的操作<br>FileMode.OpenOrCreaate：有文件就打开，没有就创建<br>FileMode.Append：向文件中追加<br>第三个参数opreateData：表示对文件中的数据进行怎么样的操作<br>FileAccess.Read：读取文件内容<br>FileAccess.Write：写入文件内容</p>
<p>使用FileStream读取：<br>1）创建一个FileStream对象<br>FileStream fsR = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Read)；<br>Path为读取的文件存储的地址</p>
<p>2）创建缓存区（字节数组）<br>byte[] buffer = new buffer[1024<em>1024</em>2];    大小为2M<br>buffer用来缓存读取到的一定量的字节数，每次读取文件时，只占用这么大的内存</p>
<p>3）    从流中读取数据，返回值为int类型<br>从流中读取字节块并将数据写入给定的缓存区<br>int r = fsR.Read(buffer,0,buffer.Length)，返回值为int类型，表示真实读到的字节数，将读到的数据存储再buffer当中</p>
<p>4）    将字节数组转换成字符串<br>string str = Encoding.Default.GetString(buffer,0,r)；<br>Concole.WriteLine(str);<br>Console.ReadKey();</p>
<p>5）    关闭流<br>fsR.Close();</p>
<p>6）    释放流<br>fsR.Dispose();</p>
<p>使用FileStream写入：<br>1）    创建FileStream对象<br>FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write);<br>Path是将要写入的文件地址</p>
<p>2）    将要写入的文件转换成字节<br>string s = “要写入的内容”;<br>byte[] buffer = Encoding.Default.GetString(s);</p>
<p>3）    将文件写入缓存区<br>fsW.Write(buffer,0,buffer.Length);</p>
<p>4）    关闭流<br>fsW.Close();</p>
<p>5）    释放流<br>fsW.Dispose();</p>
<p>为了避免关闭和释放流文件，可以使用using(){}：<br>Using(FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write))<br>{<br>    string s = “要写入的内容”;<br>byte[] buffer = Encoding.Default.GetString(s);<br>}</p>
<p>68、StreamReader、StreamWriter的使用<br>StreamReader和StreamWriter用来操作字符<br>StreamReade读取文件：<br>方法：<br>string  ReadLine();   读取文件第一行数据，并以字符串的形式返回<br>bool  EndOfStream()：获取一个值，该值表示当前的流位置是否在流的末尾</p>
<p>创建StreamReader对象：<br>StreamReader sr = new StreamReader(path,读取文件的方式);<br>读取文件的方式：Encoding.Default</p>
<p>StreamWriter写入文件：<br>方法：<br>Write():</p>
<p>69、装箱和拆箱<br>装箱：将值类型转换为引用类型<br>拆箱：将引用类型转换为值类型<br>值类型：int decimal double bool char enum struct<br>引用类型：数组 集合 string object 自定义类</p>
<p>例：<br>int n = 10;<br>object o = n;   //装箱<br>int nn = (int)o;  //拆箱</p>
<p>拆箱和装箱很浪费时间，应该避免装箱或拆箱<br>判断两个类型之间是否发生装箱或者装箱，首先要确定这两个类型之间是否存在继承关系：<br>如果存在，则有可能会发生拆箱或者装箱<br>如果不存在，则不会发生装箱或者拆箱</p>
<p>装箱时使用什么数据类型，拆箱时也必须使用该类型</p>
<p>70、泛型集合<br>1）List&lt;&gt;<br>创建ArrayList，必须引用命名空间：System.Collections<br>ArrayList arr = new ArrayList();<br>ArrayList在存储数据时，容易发生装箱和拆箱</p>
<p>创建List&lt;&gt;不需要引用命名空间<br>List<int> list = new List<int>();  //集合中只能存放int类型</int></int></p>
<p>方法：<br>Add()：添加元素    只能添加规定类型的元素<br>Remove()：移除元素<br>Reverse()：反转集合<br>Clear()：清除集合<br>ToArray()：将集合转换为数组<br>ContainsKey(Keys)：判断是否包含key值<br>2）Dictionary<key,value><br>Dictionary<int,string> dic = new Dictionary<int,string>();</int,string></int,string></key,value></p>
<p>遍历Dictionary中的元素一般用foreach<br>foreach(var item in dic.keys)<br>{<br>    Console.Write(“{0}——-{1}”,item,dic[item])；</p>
<p>}</p>
<p>KeyValuePair：键值对</p>
<p>foreach(KeyValuePair<int,string> item in dic)<br>{<br>Console.Write(“{0}——-{1}”,item.Key,item.Value)；<br>}</int,string></p>
<p>71、多态<br>概念：让一个对象能够表现出多种的状态（类型）</p>
<p>实现多态的三种方法：<br>1）    虚方法<br>步骤：<br>1、将父类的方法标记为虚方法，使用关键字virtual，作用是可以使这个方法可以被子类重写一遍<br>2、在子类的方法前面加override </p>
<p>2）    抽象类<br>标记一个类为抽象类，使用关键字abstract<br>抽象类不能创建的对象<br>抽象方法：没有方法体的方法且被abstract修饰的方法<br>  如果一个类继承了抽象类，必须重写抽象类里面的抽象方法，使用关键字override</p>
<p>1、抽象成员必须标记为abstract，并且不能有任何的实现<br>2、抽象成员必须在抽象类中<br>3、抽象类不能实例化<br>4、子类继承抽象类后，必须把父类中所有的抽象成员重写（除非子类也是一个抽象类，可以不重写）<br>5、抽象成员的访问修饰符不能是private<br>6、在抽象类中可以包含实例成员<br>7、抽象类是有构造函数的，虽然不能被实例化<br>8、如果抽象父类的抽象方法中有参数，则继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数；如果抽象父类的抽象方法中有返回值，则子类在重写这个抽象方法时，也必须要有返回值</p>
<p>如果父类中的方法有默认的实现，并且父类需要被实例化，可以考虑父类定义成一个普通类，用虚方法实现多态<br>如果父类中的方法没有默认实现，父类也不需要实例化，则可以将该类定义成抽象类</p>
<p>3）    接口</p>
<p>72、访问修饰符<br>public：公共的，公开的<br>private：私有的，只能在当前类的内部访问<br>protected：受保护的，只能在当前类以及该类的子类中访问<br>internal：只能在当前项目中访问<br>protecte internal：protected+internal</p>
<p>修饰类的访问修饰符只有两个：public、 internal</p>
<p>73、设计模式：简单工厂设计模式</p>
<p>74、序列化和反序列化<br>序列化：将对象转换为二进制<br>反序列化：将二进制转换为对象</p>
<p>作用：传输数据</p>
<p>序列化对象：BinaryFormatter<br>序列化方法：Serialize()<br>反序列化方法：Deserialize()</p>
<p>序列化和反序列化需要与流结合使用：<br>1、    将要序列化的对象所在的类标记为可以序列化，使用 [Serializable]<br>2、    创建序列化对象BinaryFormatter bf = new BinaryFormatter();<br>3、    序列化：调用Serialize(写入的流对象,需要序列化的对象)<br>4、    反序列化：调用Deserialize(读取的流对象)</p>
<p>75、<br>Guid.NewGuid()：能创建一个独一无二的ID<br>string s = Guid.NewGuid().ToString()；</p>
<p>76、接口<br>单继承：一个类只能有一个接口<br>多接口：一个类可以有多个接口<br>定义接口：<br>[public] interface 接口名称<br>{<br>    接口成员;<br>}<br>接口中不能有实例方法；<br>抽象类中可以有抽象方法，也可以有实例方法；<br>接口中的成员默认为public，普通的类中的成员默认为private</p>
<p>子类必须重写抽象类中的抽象方法，重写方法使用关键字override<br>子类必须实现接口中的抽象方法，不需要使用关键字override</p>
<p>1）接口是一种规划，只要一个类继承了一个接口，就必须实现接口中的所有成员<br>2）接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为public，不能修改<br>3）接口中只能由方法、属性、索引器、事件，不能有字段和构造函数<br>4）接口与接口之间可以继承，并且可以多继承<br>5）接口不能继承类，类可以继承接口（接口只能继承于接口，类既可以继承接口，也可以继承类）<br>6）一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA，那么语法上A必须写在IA的前面，因为类是单继承的<br>7）显示实现接口：目的是解决方法的重名问题。当继承的接口中的方法和参数一模一样时，用显示的实现接口，尽量不要接口里的方法名字一个方法<br>实现接口中的方法用：void 接口名.方法(){}<br>例子：void IEatable.Eat(){}</p>
<p>8）当一个抽象类实现接口时，需要抽象类的子类去实现接口<br>9）接口的命名：一般以I开头，以able结尾<br>10）接口中可以有返回值或者参数</p>
<p>多态：一个变量表现出多种状态<br>继承 声明一个父类，展示多个子类的特性</p>
<p>只要一个类，继承或者实现就可以这样写<br>还有一个虚方法也可以这样写</p>
<p>Person p = new Student();</p>
<p>抽象类和接口都不允许创建对象<br>静态类也不能创建对象</p>
<p>77、值传递和引用传递<br>值类型：int、double、decimal、bool、char、enum、struct  都继承于valueType<br>引用类型：string 数组 集合 自定义类 object 接口 </p>
<p>值传递：值类型在赋值的时候，传递的是值本身<br>引用类型：引用类型在赋值的时候，传递的是引用（地址）</p>
<p>78、重写父类中的方法<br>Tostring()<br>Equals()</p>
<p>79、MD5加密<br>明文保持<br>MD5值保持<br>MD5本质上就是一个算法，且算法是不可逆的<br>使用步骤：<br>1）    创建MD5对象<br>MD5是一个抽象类，但是类中有2个静态的方法<br>MD5 md = MD5.Create();  创建MD5对象<br>2）    调用ComputeHash(string str)，返回值为一个字节数组<br>3）将字节数组转换成字符串 Encoding.Default.GetString(byte)</p>
<p>80、Encoding类<br>1）将字符串转换为字节数组<br>Encoding.Default.GetBytes(string str);<br>2）将字节数组转换为字符串<br>Encoding.Default.GetString(byte[] by)<br>Default为默认的读取方式，还可以换成UFT-8、Unicode…</p>
<p>ToString()：是什么就转换成什么<br>GetString()：转换成有意义的字符串</p>
<p>81、密封类和部分类<br>partial：表示部分类，表示一个类的一部分，各个部分组成一个类。<br>sealed：表示密封类，被关键字sealed修饰的类表示这个类不能被继承，但可以继承其他类</p>
<p>82、winform窗体应用程序  桌面应用程序开发<br>Winform窗体应用程序是一种智能的客户端技术，交互模式是C/S，要求用户必须安装一个客户端<br>通过它，可以智能的获取数据和显示数据<br>开发包括：<br>1）<br>2）UI设计<br>拖动一个控件就是一个创建对象的过程</p>
<p>Winform窗体的执行过程：<br>1）</p>
<p>2）</p>
<p>3）</p>
<p>InitializeComponent()：对窗体以及窗体对象进行初始化<br>4）</p>
<p>对Form1.Designer.cs几乎不操作<br>主要操作： </p>
<p>快捷键：F4，转到属性<br>属性：<br>窗体的属性：点击窗体，按F4进入窗体的属性设置<br>控件的属性：点击控件，按F4进入控件的属性设置</p>
<p>83、事件<br>事件：例如单击、双击…</p>
<p>事件的本质就是一个方法<br>事件要是想执行，必须有人触发它</p>
<p>注册的默认事件，单击就可以进入方法里，如窗体的加载事件（Load）、按钮的单击事件（Click）</p>
<p>Object Sender表示触发事件的对象<br>EventArgs e表示执行执行对象的参数和资源</p>
<p>给控件添加事件<br>选择控件，F4进入属性设置，选择事件，点击任意事件就可以进入事件的方法里</p>
<p>84、控件<br>TextBox文本框<br>WordWap 自动换行<br>Focus 聚焦<br>Visible 是否可见<br>Clear 清除内容<br>Button 按钮<br>Label 标签<br>Timer 定时器，让一个事件每隔多长事件执行一次</p>
<p>85、MDI窗体设计<br>主窗体中包含很多的子窗体<br>设置主窗体 IsMdiContainer = true；</p>
<p>86、OpenFileDialog类</p>
<p>87、GDI+<br>GDI+（Graphics Device Interface）是一种绘图装置接口，可将应用程序和绘图硬件分隔，让我们能够编写与装置无关的应用程序。它可以让我们不需要注意特定显示装置的详细数据，便可在屏幕或打印机显示信息。我们可以呼叫GDI+类别所提供的方法，然后这些方法会适当呼叫特定的装置驱动程序，而完成绘图。而且与.NET进行了更好的融合。</p>
<p>GDI+就是画图的</p>
<p>88、.NET FrameWork框架<br>框架容2部分构成：<br>1）.NET 类库<br>小写的string 和大写的String在编译后，都会映射为String类<br>string 为关键字<br>String 为类名<br>2）CLR Common Language Runtime 公共语言运行时<br>当我们点击F5运行程序时，CLR首先加载所有的类文件到内存中，找到其中的主函数，从上到下，一行一行的执行。<br>基于.Net有很多语言开发，如C# 、C++….   .Net平台实现了一个语言无关性<br>如何实现语言无关性：<br>C#  ===》编译为IL（MSIL） 中间语言 ===》由CLR执行IL </p>
<p>89、GDI+的坐标系统<br>在GDI+中所采用的坐标系统，x轴和y轴分别是往右往下递增</p>
<p>90、GDI+的使用<br>1）创建对象<br>Graphics是一个密封类，无法创建对象<br>通过当前窗体创建一个GDI对象：Graphics g = this.CreateGraphics()；<br>2）画图<br>画直线：笔 纸 两个点 颜色 你<br>创建两个点：Point p1 = new Point(50,50);<br>            Point p2 = new Point(100,100);<br>创建一个刷子：Brush类，不能创建对象，直接调用方法<br>创建一个笔：Pen  p = new Pen(Brush.Yellow);<br>画直线：g.DrawLine(pen,p1,p2);</p>
<p>画矩形：<br>Graphics g = this.CreateGraphics();<br>Size size = new System.Drawing.Size(150,150);<br>Rectangle rec = new Rectangle(new Point(220,220),size);<br>g.DrawRectangle(new Pen(Brushes.Red),rec);</p>
<p>填充一个矩形：<br>g.FillRectangle(Brushes.Yellow,rec);</p>
<p>写字：<br>Graphics g = this.CreateGraphics();<br>g.DrawString(“内容”,new Font(“宋体”,FontStyle.Bold,20),Brushes.Red,new Point(240,240));</p>
<p>91、图形类所在的命名空间<br>System.Drawing：提供了对GDI+基本图形功能的访问的类；<br>System.Drawing.Imaging：提供高级GDI+图像处理功能的类；<br>System.Drawing.Text：提供高级GDI+排版功能，该命名空间中的类允许用户创建和使用多种字体的类；</p>
<p>92、画验证码<br>承载图片的控件：PictureBox<br>图片大小单位：像素</p>
<p>画任何东西都要坐标</p>
<p>1）产生随机数，拼接成字符串<br>2）创建图片，指定高度和宽度  Bitmap bmp = new Bitmap(120,25);<br>3）创建GDI对象，用来画图片的   Graphic g = Graphics.FromImage(bmp);<br>4）申明两个数组，存放字体样式和颜色<br>5）确定随机数的坐标，横坐标必须有间隔  坐标是相当于PictureBox而言<br>6）画线<br>7）画像素颗粒</p>
<p>93、多线程<br>进程：每一个应用程序都是一个进程<br>进程由多个线程组成的<br>进程类：Process<br>Process.GetProcesses();  获取当前所有的线程<br>Process.kill();  杀掉进程<br>Process.GetCurrentProcess(); 获得当前的进程<br>Process.Start(进程名);  开启一个进程</p>
<p>主线程：程序写好之后，CPU会分配一个主线程，主线程用来创建窗体、控件</p>
<p>线程类：Thread<br>产生一个线程的步骤：<br>1）    编写产生线程所要执行的方法   Test<br>2）    引用System.Threading命名空间<br>3）    实例化Thread类，并传入一个指向线程所要运行方法的委托  Thread th = new Thread(Test);<br>4）    调用Thread实例的Start方法，标记该线程可以被CPU执行，但具体的执行时间由CPU决定</p>
<p>Thread类的重要成员：<br>Start();   启动线程   只是告诉CPU，该线程已经准备好了，启动线程最终由CPU决定<br>Abort();  终止线程     线程一旦被关闭了，就不能再被打开，Abort之后无法再Start<br>Thread.Sleep(1) 静态方法，可以使当前线程停止一段时间运行<br>Name 线程名<br>Thread.CurrentThread 获取当前的线程引用</p>
<p>前台线程和后台线程<br>前台线程：只有所有的前台线程都关闭才能完成程序关闭<br>后台线程：只要所有的前台线程结束，后台线程自动结束</p>
<p>th.IsBackgroud = true；设置为后台线程</p>
<p>跨线程访问   .Net不允许跨线程访问<br>Control.CheckForIllegalCrossThreadCalls = false;     取消对跨线程访问的检查</p>
<p>关闭其他线程时，需要同时关闭线程里面的其他线程里的东西</p>
<p>94、Socket网络编程</p>
<p>Socket负责应用程序之间的通信<br>Socket的英文原义为孔或是插座，作为进程通信机制，。通常也称之为套接字，用于描述IP地址和端口，是一个通信的句柄。</p>
<p>协议：可以理解为规定沟通用的语言  如：tcp协议 http协议</p>
<p>Socket相关概念（端口）<br>在Internet上有很多这样的主机，这些主机一般运行了很多个服务软件，同时提供几种服务。每种服务都打开了一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务（应用程序）。例如：http使用80端口  ftp使用21端口  smtp使用25端口</p>
<p>两种类型的Socket：<br>1）    流式Socket（STREAM）：<br>是一种面向连接的Socket，针对于面向连接的TCP服务应用，安全，但是效率低；（三次握手）<br>2）    数据报式<br>是一种无连接的Socket，对应于无连接的UDP服务应用，不安全（丢失数据、顺序混乱、在接收端要分析重排及要求重发），但效率高</p>
<p>Socket的通讯过程：<br>服务器端：<br>    申请一个socket<br>    绑定到一个IP地址和一个端口上<br>    开启监听，等待接受连接<br>客户端：<br>    申请一个socket<br>    连接服务器（指明IP和端口号）<br>服务器端接到连接请求后，产生一个新的socket与客户端建立连接并进行通讯，原监听socket继续监听。</p>
<p>注意：<br>至少要定义一个要连接的远程主机的IP和端口号，端口号必须在1和6553之间，最好在1024以后；<br>要连接的远程主机必须正在监听指定的端口，也就是说无法随意连接远程主机<br>如：<br>IPAddress addr = IPAddress.Parse(“127.0.0.1”);<br>IPEndPoint endp = new IPEndPoint(addr.100001);<br>服务器端先绑定：serverWelcomSocket.Bind(endp);<br>客户端再连接：clientSocket.Connect(endp);</p>
<p>创建Socket对象：<br>Socket socket = new Socket(IP型号，socket类型，对应的协议);<br>如：<br>Socket socket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);<br>AddressFamily.InterNetwork： IPV4<br>SocketType.Stream：流式Socke<br>ProtocolType.Tcp：对应的TCP协议</p>
<p>AddressFamily、SocketType、ProtocolType都为枚举类型</p>
<p>Socket一般应用模式（服务器端和客户端）<br>服务器端的Socket（至少需要2个）：<br>1、    一个负责接收客户端请求连接请求（但不负责与客户端通信）<br>2、每成功接收到一个客户端的连接便在服务端产生一个对应得负责通信的Socket<br>    在接收客户端连接时创建<br>    为每个连接成功的客户端请求在服务端都创建一个对应的Socket<br>客户端的Socket：<br>1、    必须指定要连接的服务端的地址和端口<br>2、    通过创建一个Socket对象来初始化一个到服务器端的TCP连接</p>
<p>TCP协议的三次握手：<br>1、    Client问Server：你有空嘛？<br>2、    Server回答：有空<br>3、    Client回答：我知道了，我准备发送数据了</p>
<p>1、    服务端welcoming socket开始监听端口<br>2、    客户端client socket连接服务端指定端口<br>3、    服务端welcoming socket监听到客户端连接，创建connection socket</p>
<p>95、Socke通信</p>
<p>监听队列：表示在某个时间点可以连入服务端的最大客户端的数量</p>
<p>Telnet Client 允许本地计算机连接远程的计算机<br>Telnet Server 允许远程计算机连接本地计算机</p>
<p>//创建负责监听的socket<br>Socket socketWatch = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);<br>//创建IP和端口<br>// IPAddress ip =IPAddress.Parse(txtServer.Text);  //Parse()讲字符串转换成IP地址<br>IPAddress ip = IPAddress.Any;<br>IPEndPoint port = new IPEndPoint(ip,Convert.ToInt32(txtPort.Text));<br>socketWatch.Bind(port);    //让负责监听的Socket绑定IP地址和端口号<br>socketWatch.Listen(10);     //建立监听队列<br>//负责监听的socket 来接受客户端的连接 创建与客户端通信的socket<br>Socket socketSend = socketWatch.Accept();</p>
<p>当客户端没有连接时，服务端会一直等待客户端的连接，所以，程序会一直停在这里，窗口卡死，所以，采用多线程的方式执行Listen()方法。</p>
<p>96、多线程执行带参数的方法</p>
<p>线程执行的方法中，如果带有参数，那么这个参数必须是object类型<br>在所执行的方法里，将object类型转化成想要的类型</p>
<p>凡是设计到网络的地方都try…catch</p>
<p>97、启动另外一个Winform应用程序<br>项目右击——- &gt;调试———- &gt;启动新实例</p>
<p>98、手动写协议</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C#</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/24/C#学习阶段一/" rel="next" title="C#学习阶段一">
                <i class="fa fa-chevron-left"></i> C#学习阶段一
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="chenia">
            
              <p class="site-author-name" itemprop="name">chenia</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenia" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:cheniavip@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenia</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">13.9k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
