<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C#,">





  <link rel="alternate" href="/atom.xml" title="Chenia's Blog" type="application/atom+xml">






<meta name="description" content="常量\枚举\结构常量 定义一个常量 ：const 类型 常量名 = 常量值；  枚举 定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举  确定数量、确定值的几个取值可以使用枚举 语法： [public] enum 枚举名 {     值1；     值2；     ……. } 注意：  枚举名的命名规范必须符合 Pascal的命名规范 和字">
<meta name="keywords" content="C#">
<meta property="og:type" content="article">
<meta property="og:title" content="C#学习阶段二">
<meta property="og:url" content="http://yoursite.com/2019/09/24/dotNet学习阶段二/index.html">
<meta property="og:site_name" content="Chenia&#39;s Blog">
<meta property="og:description" content="常量\枚举\结构常量 定义一个常量 ：const 类型 常量名 = 常量值；  枚举 定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举  确定数量、确定值的几个取值可以使用枚举 语法： [public] enum 枚举名 {     值1；     值2；     ……. } 注意：  枚举名的命名规范必须符合 Pascal的命名规范 和字">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-24T14:47:43.010Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C#学习阶段二">
<meta name="twitter:description" content="常量\枚举\结构常量 定义一个常量 ：const 类型 常量名 = 常量值；  枚举 定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举  确定数量、确定值的几个取值可以使用枚举 语法： [public] enum 枚举名 {     值1；     值2；     ……. } 注意：  枚举名的命名规范必须符合 Pascal的命名规范 和字">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/24/dotNet学习阶段二/">





  <title>C#学习阶段二 | Chenia's Blog</title>
  








</head>
<script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Tomorrow is another chance</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/dotNet学习阶段二/">
   
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenia">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenia's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C#学习阶段二</h1>
        

        <div class="post-meta">
		  
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T13:33:18+08:00">
                2019-09-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-24T22:47:43+08:00">
                2019-09-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1><span id="常量枚举结构">常量\枚举\结构</span></h1><h2><span id="常量">常量</span></h2><blockquote>
<p><strong>定义一个常量 ：const 类型 常量名 = 常量值；</strong></p>
</blockquote>
<h2><span id="枚举">枚举</span></h2><blockquote>
<p><strong>定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举</strong></p>
</blockquote>
<p>确定数量、确定值的几个取值可以使用枚举</p>
<p><strong>语法：</strong></p>
<pre><code>[public] enum 枚举名
{
    值1；
    值2；
    …….
}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>枚举名的命名规范必须符合 Pascal的命名规范</li>
<li><p>和字符串比，用枚举的好处就是限定了变量的取值范围</p>
<blockquote>
<p>例：</p>
</blockquote>
<pre><code>    enum Gender{male,female}
      enum Status{Online,offline,hidden};
</code></pre><blockquote>
<p>用法：</p>
</blockquote>
<pre><code>  Status s  s =  Status.online;
</code></pre></li>
</ul>
<h2><span id="枚举类型与int类型和string类型之间的转换">枚举类型与int类型和string类型之间的转换</span></h2><blockquote>
<p>枚举类型和int类型相互兼容，所以两种类型可以通过强制类型转换的语法相互转换，枚举类型的默认值是从0开始的。</p>
</blockquote>
<h2><span id="结构">结构</span></h2><p><strong>作用：可以一次性声明不同类型的变量</strong></p>
<p><strong>语法：</strong></p>
<pre><code>[public] struct 结构名
{
    结构成员;
}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>结构名的命名规范必须符合,Pascal的命名规范</li>
<li>写在命名空间下</li>
<li>结构体内的不叫变量，叫字段，字段的命名习惯在前面加下划线</li>
</ul>
<h1><span id="数组">数组</span></h1><blockquote>
<p><strong>定义一个数组：数组类型[] 数组名 = new 数组类型[数组长度];</strong></p>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>数组的长度一旦声明了，就不能再改变了</li>
<li>数组里存储的只能是同一种数据类型</li>
</ul>
<p>声明数组的4种方式：</p>
<pre><code>int[] l1 = new int[4];//只定义了一个数组，未赋
int[] l2 = { 8, 2, 1, 4, 7, 6, 5, 9, 3};
int[] l3 = new int[4] { 1, 2, 3, 4 };
int[] l4 = new int[] { 1, 2, 3, 4 };
</code></pre><h1><span id="变量的作用域">变量的作用域</span></h1><blockquote>
<p><strong>一般变量的作用范围为定义时所在的大括号到结束时的大括号的范围内</strong></p>
</blockquote>
<ul>
<li>局部变量</li>
<li>全局变量：作用范围为全类，必须为static，且在class后面定义；</li>
</ul>
<h1><span id="out参数">out参数</span></h1><blockquote>
<p><strong>out参数可以帮助我们在一个方法中返回多个值，不限类型</strong></p>
</blockquote>
<p><strong>语法：</strong></p>
<pre><code>int s;
调用ze(out s)
被调用ze(out int s){….}
或者 
调用 ze(out int s)
被调用ze(out int s){….}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>out参数必须在方法内赋值</li>
<li>调用者内必须传入：out  变量名</li>
<li>被调用者内定义out 数据类型 变量名</li>
</ul>
<h1><span id="ref-参数">ref 参数</span></h1><blockquote>
<p><strong>ref参数是将一个变量以参数的形式带到一个方法中进行改变，改变完成后，再将改变后的值带出来。</strong></p>
</blockquote>
<pre><code>int s = 0;
调用ze(ref s)
被调用ze(ref int s){….}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>ref参数在方法外必须为其赋值</li>
</ul>
<h1><span id="方法的重载">方法的重载</span></h1><blockquote>
<p><strong>方法的重载指的是方法名称相同，但是参数不同。</strong></p>
</blockquote>
<ul>
<li>如果参数的个数相同，那么参数的类型就不能相同</li>
<li>如果参数的类型相同，那么参数的个数就不能相同</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>方法的重载和返回值无关</li>
</ul>
<h1><span id="params-参数">params 参数</span></h1><blockquote>
<p>可变参数数组<br>作用：将某些值默认加入到数组中</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>这些值的类型必须相同</li>
<li>被params修饰的形参只能做最后一个形参</li>
</ul>
<h1><span id="面向对象">面向对象</span></h1><blockquote>
<p><strong>面向对象三大特征：继承 封装 多态</strong></p>
</blockquote>
<p><strong>语法：</strong></p>
<pre><code>[访问修饰符]  class  类名
{
    类的成员; //字段、属性、方法

}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>访问修饰符 public </li>
<li>类名：pascal 要求每个首字母大写</li>
<li>写好一个类之后，需要创建这个类的对象，我们管创建这个类的对象的过程称之为类的实例化,使用关键字new</li>
<li>类是不占内存的，对象占内存</li>
</ul>
<h1><span id="this">this</span></h1><blockquote>
<p><strong>this代表当前类的  对象</strong></p>
<p>作用：</p>
<ul>
<li>代表当前类的对象</li>
<li>显示的调度自己的构造函数</li>
</ul>
</blockquote>
<h1><span id="类成员">类成员</span></h1><p>类的成员可以有：</p>
<ul>
<li>字段：存储数据  一般为私有的</li>
<li>属性：保护字段</li>
<li>方法：对象行为</li>
<li>构造函数：初始化对象</li>
</ul>
<h1><span id="修饰符-private">修饰符  private</span></h1><p>类中的成员如果不加访问修饰符，默认为private<br>private表示私有的，只能在当前类的内部访问，出了这个类之后，就访问不到了</p>
<h1><span id="属性">属性</span></h1><blockquote>
<p><strong>属性是为了保护字段不被随意的修改</strong></p>
<p><strong>字段的属性本质上是由get/set方法构成  属性的本质就是方法</strong></p>
</blockquote>
<ul>
<li>给字段赋值时，调用set方法</li>
<li>取值时，调用get方法</li>
</ul>
<ul>
<li>Fields   字段</li>
<li>Methods   方法</li>
<li><p>Properties  属性</p>
<pre><code>  string   _name
  public string Name
  {
     Get { return _name;}
     Set{ _name = value;}
  }
</code></pre></li>
</ul>
<ul>
<li><p>自动属性：不需要写字段的</p>
<pre><code>  public string Name
  {
      get;
      set;
  }
</code></pre></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>字段是：_name   属性是：Name</li>
<li>应该给每个字段都配上属性</li>
</ul>
<h2><span id="三种属性">三种属性</span></h2><ul>
<li>既有get方法也有set方法，称之为可读可写属性</li>
<li>只有get方法没有set方法，称之为只读属性</li>
<li>只有set方法没有get方法，称之为只写属性</li>
</ul>
<h1><span id="构造函数构造方法">构造函数（构造方法）</span></h1><blockquote>
<p>构造函数的作用是对对象进行初始化<br>构造函数本质就是一个函数，特殊的函数</p>
</blockquote>
<p><strong>语法:</strong></p>
<pre><code>public 构造函数名()
{
    代码;
}
</code></pre><ul>
<li>public必须要</li>
<li>没有返回值void都不需要</li>
<li>构造函数的名称必须与类名相同</li>
</ul>
<p>调用构造函数</p>
<p><strong>new的作用</strong>：</p>
<ul>
<li>在堆内存中开辟空间</li>
<li>在开辟的堆空间中创建对象</li>
<li>调用对象的构造函数</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>可以重载</li>
<li>类中默认会有一个无参数的构造函数，当重写了构造函数后，默认的构造函数失效</li>
</ul>
<h1><span id="值类型和引用类型">值类型和引用类型</span></h1><ul>
<li>值类型：int double char bool decimal struct enum</li>
<li>引用类型：string 数组 自定义类</li>
</ul>
<p><strong>存储数据的地方：堆 栈 静态存储区域:</strong></p>
<ul>
<li>值类型：值类型的值存储在栈中</li>
<li>引用类型：引用类型的值存储在堆中</li>
</ul>
<h1><span id="静态和非静态的区别">静态和非静态的区别</span></h1><blockquote>
<p><strong>区别：有没有static</strong> </p>
</blockquote>
<ul>
<li>在非静态类中，可以有静态成员，也可以有非静态成员  </li>
<li>在非静态方法中，可以访问静态成员，也可以访问非静态成员</li>
<li>在静态方法中，只允许访问静态成员</li>
<li>在静态类中，不能出现非静态成员，只能有静态成员</li>
</ul>
<blockquote>
<p><strong>在调用上的区别：</strong></p>
</blockquote>
<ul>
<li>在调用实例成员时，需要使用对象去调用</li>
<li>在调用静态成员时，必须使用类名.静态成员</li>
</ul>
<blockquote>
<p>静态类不允许创建对象的，静态类的成员，全部用类名.静态成员</p>
</blockquote>
<p>什么时候用静态类？什么时候用非静态类？</p>
<p>如果类属于工具类（非常常用），可以写成静态类</p>
<blockquote>
<p>类不占内存，但静态类占用内存，占用静态存储区域，静态类的资源共享</p>
<p>静态类应该越少越好</p>
<p>静态类释放资源时，必须等待所有的程序结束的时候才能被释放</p>
</blockquote>
<h1><span id="垃圾回收期和析构函数">垃圾回收期和析构函数</span></h1><blockquote>
<p><strong>GC：gargbage collection</strong></p>
<p>当程序结束后，GC会扫描整个内存，如果有空间没有被指向，则把该空间销毁<br>析构函数是C语言里回收垃圾的</p>
</blockquote>
<h1><span id="字符串">字符串</span></h1><p>字符串具有不可变性：当给字符串重新赋值时，其实是在内存中重新开辟一块空间存储值。<br>由于字符串的不可变性，当需要给一个字符串进行大量的拼接、赋值等操作时，会产生大量的内存垃圾；可以使用StringBuilder</p>
<p>一切类型都可以调用ToString()方法转换成字符串类型</p>
<p><strong>方法：</strong></p>
<ul>
<li>ToCharArrray()：将字符串转换成char类型的数组</li>
<li>New string(char[]  chs)：将一个字符数组转换成一个字符串</li>
<li>Length：查看字符串的长度</li>
<li>ToUpper：转换成大写</li>
<li>ToLower：转换成小写</li>
<li>Equals(“要比较的字符串”,StringComparison.OrdinalIgnoreCase)：比较字符串是否相同，忽略大小写;</li>
<li>Split：分割字符串，返回一个字符串的数组</li>
<li>Split(char[]  ch,StringSplitOptions.RemoveEmptyEntries ) ：ch是分割的内容，后面是分割后替代的内容</li>
<li>Replace：替代字符串</li>
<li>Replace(string oldValue,string newValue)：将字符串中出现的oldValue的地方替换为newValue</li>
<li>SubString：截取字符串</li>
<li>Substring(int startindex)：从位置startIndex开始截取到最后的子字符串</li>
<li>SubString(int startindex,int length)：从位置startINdex开始截取长度为length的子字符串，如果长度不够则会报错；</li>
<li>Contains(string value)：判断字符串中是否含有子串value</li>
<li>StartsWith(string value)：判断字符串是否以子串value开始</li>
<li>EndsWith(string value)：判断字符串是否以子串value结束</li>
<li>IndexOf(string value)：子串value第一次出现的位置</li>
<li>IndexOf(strinf value,int startIndex)：例如：value第一次出现的位置是1，找第二个value植时，startIndex需要加1，若找不到时，会返回-1</li>
<li>LastIndexOf(string value)：</li>
<li>Trim：去掉字符串中的空格</li>
<li>Trim()：去掉两边的空格</li>
<li>TrimEnd()：去掉后面的空格</li>
<li>TrimStart()：去掉前面的空格</li>
<li>Join：连接</li>
</ul>
<h1><span id="继承">继承</span></h1><blockquote>
<p><strong>语法： 用 : 要继承的类</strong></p>
</blockquote>
<ul>
<li>为什么要继承<blockquote>
<p>将一些类中共同具有的属性和方法单独拿出来封装成一个父类。</p>
</blockquote>
</li>
</ul>
<p>面向对象的三大特征：封装 继承 多态</p>
<p>如果一个类继承了另一个类，则称这个类为子类（派生类），被继承的类为父类（基类）。</p>
<p>子类继承父类：<br>子类继承属性和方法<br>子类不能继承私有字段，不能继承构造函数</p>
<p><strong>注意：</strong></p>
<ul>
<li>子类并没有继承父类的构造函数，但是会默认的调用父类的无参的构造函数；当在父类中重写了构造函数后，默认的无参构造函数就不存在了，此时，子类就无法调用父类的无参构造函数</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>在子类中重写一个无参的构造函数</li>
<li>让子类调用父类有参的构造函数，使用关键字 :base</li>
</ul>
<p><strong>继承的两个特性：</strong></p>
<ul>
<li>单根性 一个子类只有一个父类（一个儿子只能有一个爸爸）</li>
<li>传递性 子类可以继承父类的父类</li>
</ul>
<p>Object类是一切类型的基类</p>
<h1><span id="new-关键字">new 关键字</span></h1><blockquote>
<p>如果子类中的方法和父类重名了，子类若想继续使用该方法，可以在子类的方法内增加关键字 new 将相同名称的父类的方法隐藏掉，</p>
</blockquote>
<pre><code>public new void 相同名称的方法名()
{….  }
</code></pre><h1><span id="里氏转换">里氏转换</span></h1><ul>
<li>子类对象可以赋值给父类（如果有一个地方需要一个父类作为参数，可以用子类代替）</li>
<li>如果这个父类中装的是子类对象，那么可以将这个父类强转为对应的子类对象</li>
</ul>
<p>子类：student<br>父类：person</p>
<pre><code>Students s = new Student();
Person p = s;
Student ss = (Student)p;
</code></pre><h1><span id="asis-关键字">as/is 关键字</span></h1><ul>
<li>is：判断能否进行类型转换，如果转换成功，返回true，转换失败，返回false</li>
<li>as: 判断能否进行类型转换，如果转换成功，返回对应的对象，如果转换失败，返回一个null</li>
</ul>
<h1><span id="集合">集合</span></h1><p><strong>using System.Collections</strong></p>
<ul>
<li>ArrayList</li>
<li>Hashtable</li>
<li>List<t></t></li>
<li>Dictionary<t,t></t,t></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>数组的长度不可改变</li>
<li>集合的长度可以任意改变</li>
</ul>
<h2><span id="arraylist">ArrayList：</span></h2><p><strong>方法</strong>：</p>
<p><strong>添加：</strong></p>
<ul>
<li>Add(value)：添加单个元素</li>
<li>AddRange(value)：添加集合或者数组</li>
</ul>
<p><strong>删除</strong>：</p>
<ul>
<li>Clear()：删除集合中所有的所有</li>
<li>Remove(value)：根据值删除单个元素，如果没有value，程序不报错</li>
<li>RemoveAt(index)：根据索引删除单个元素</li>
<li>RemoveRange(startIndex,endIndex)：删除指定范围内的元素</li>
</ul>
<p><strong>插入：</strong></p>
<ul>
<li>Insert(Index,value)：在指定的索引上添加值</li>
<li>InsertRange(Index,value)：在指定的索引上添加数组或者集合</li>
</ul>
<p><strong>其他：</strong></p>
<ul>
<li>Contains()：判断是否包含</li>
<li>Sort()：排序</li>
<li>Count：获得长度   数组是Length</li>
<li>Max()：找出最大值</li>
<li>Min()：找出最小值</li>
<li>AVG()：求平均值</li>
</ul>
<h2><span id="集合的长度">集合的长度</span></h2><ul>
<li>Count：集合中实际包含的长度</li>
<li>Capcity：集合可以包含的长度</li>
</ul>
<blockquote>
<p>当向集合中添加1个元素时，集合的capcity=4；<br><br>当添加的元素超过4个时，集合的capcity=12；</p>
</blockquote>
<h2><span id="hashtable">Hashtable</span></h2><blockquote>
<p>可以称为字典，存储的是键值对</p>
<p><strong>在键值对集合中，键一定是唯一的，不能重复，值可以重复</strong></p>
</blockquote>
<p><strong>方法：</strong></p>
<ul>
<li>Add(key,value)：添加键值对</li>
<li>foreach：循环集合中的元素</li>
<li>foreach(var  item  in  collection)</li>
<li>keys：获得集合中的键值对    集合[key]=value</li>
<li>clear()：清除集合中键值对</li>
<li>contains()：是否包含元素</li>
<li>containsKey(key)</li>
<li>containsValue(value)</li>
<li>remove(key)：根据键移除元素</li>
</ul>
<h1><span id="var-推断类型">var 推断类型</span></h1><ul>
<li>C#是一门强类型语言，每一种变量必须有一个明确的定义</li>
<li>JavaScript是一门弱类型语言</li>
<li>var 可以通过变量的推断变量的类型</li>
</ul>
<blockquote>
<p>GetType()：获得变量的数据类型</p>
</blockquote>
<h1><span id="file类-静态类">File类 静态类</span></h1><p><strong>在System.IO命名空间下</strong></p>
<ul>
<li>静态类不能创建对象</li>
<li>静态类的成员都是静态成员，可以直接类名.成员调用</li>
</ul>
<p><strong>File类：操作文件的类（不是文件夹）</strong></p>
<p><code>OpenFileDialog ofd = new OpenFileDialog();</code></p>
<p><strong>File.方法：</strong></p>
<ul>
<li>Exits(文件地址)：判断文件是否存在</li>
<li>Create(文件地址)：创建文件</li>
<li>Delete(文件地址)：删除文件</li>
<li>Copy(源文件地址,复制文件地址)：复制文件</li>
<li>Move(源文件地址,复制文件地址)：移动文件</li>
</ul>
<p><strong>读取文件：</strong></p>
<ol>
<li><p>String[]  str  =  ReadAllLines(文件地址,读取文件的编码方式)：一行一行读取文件，返回值为字符串数组</p>
<pre><code> Encoding.Default：默认方式
 Encoding.UTF-8
 Encoding.Unicode
</code></pre></li>
<li><p>String str = ReadAllText(文件地址,读取文件的编码方式)：读取整个文本，返回值为字符串<br><code>ReadAllLines()</code>和<code>ReadAllText()</code>只能读取txt文件</p>
</li>
</ol>
<ol>
<li>byte[] buffer = ReadAllBytes(文件地址);buffer里存的都是数字，需要将buffer转换成字符串，使用<code>string  str  =Enconding.Default.GetString(buffer)</code>;</li>
</ol>
<p><code>ReadAllBytes()</code>可以操作任何格式的文件</p>
<pre><code>Enconding.Default.GetString();
Enconding.UTF-8.GetString();
Enconding.Unicode.GetString();
Enconding.GetEncoding(“GBK”).GetString();
</code></pre><ul>
<li>1024byte=1kb</li>
<li>1024kb=1M</li>
</ul>
<h1><span id="导入命名空间的快捷方式">导入命名空间的快捷方式</span></h1><ol>
<li>使用快捷键 alt+shift+F10</li>
<li>使用鼠标的方式</li>
</ol>
<h1><span id="编码">编码</span></h1><blockquote>
<p>乱码的原因：保持文件所采取的编码格式与打开文件的编码格式不一致</p>
<p>文本文件编码，文本文件有不同的存储方式，将字符串以什么样的形式保存为二进制，这个就是编码，UTF-8、ASCII、Unicode等，如果出现乱码一般就是编码的问题，文本文件相关的函数一般都有Encoding类型的参数，取得编码的方式：<code>Encoding.Default</code>、<code>Encoding.UTF8</code>、<code>Encoding.GetEncoding(“GBK”)</code></p>
</blockquote>
<p>输出<code>Encoding.GetEncodings()</code>，所有的编码</p>
<p><strong>常用的静态方法：</strong></p>
<ul>
<li>void  AppendAllText(string path,string contents,编码方式)：将文本contents附加到文件path中</li>
<li>bool  Exists(string path)：判断文件path是否存在</li>
<li>string[]  ReadAllLines(string path)：读取文本文件到字符串数组中</li>
<li>string  ReadAllText(string path)：读取文本文件到字符串中</li>
<li>void  WriteAllText(string path,string contents)：将文本contents保持到文件path中，会覆盖旧内容</li>
<li>void  WriteAllLines(string path,string[] contents)：将字符串数组逐行保存到文件path中，会覆盖旧内容</li>
</ul>
<h1><span id="directory类">Directory类</span></h1><blockquote>
<p>Directory类：操作文件夹</p>
<p>Directory类 静态类  在System.IO命名空间下</p>
<p>静态类不能创建对象</p>
<p>静态类的成员全部为静态成员，直接类名调用</p>
</blockquote>
<ul>
<li>CreateDirectory(string path)：创建文件夹</li>
<li>Delete(string path,true)：删除文件夹 </li>
<li>Move(string oldpath,string newpath)：剪切文件夹</li>
<li>String[]  path  =  GetFiles(string path,匹配项)：获得文件夹下与匹配项相同的所有文件</li>
</ul>
<h1><span id="path类-静态类">path类 静态类</span></h1><p><strong>在System.IO命名空间下</strong></p>
<ul>
<li>path类：操作路径</li>
<li>GetFileName()：获得文件名   </li>
<li>GetFileNameWithoutExtension()：获得除去拓展名的文件名  </li>
<li>GetExtension()：获得文件的拓展名</li>
<li>GetDirectoryName()：获取文件夹名</li>
<li>GetFullPath()：获取绝对路径</li>
<li>Combine(params,path)：连接路径</li>
</ul>
<h1><span id="文件流">文件流</span></h1><blockquote>
<p>File类的弊端：读写速度太慢，只能读写小文件，因为它是将文件一次性读写出来的</p>
<p>文件流读写文件时，每次只占用规定的缓存区大小</p>
</blockquote>
<p><strong>文件流：FileStream、StreamReader、StreamWriter</strong></p>
<ul>
<li>FileStream：用来操作字节的<blockquote>
<p>方法：Read()、Write()</p>
</blockquote>
</li>
<li>StreamReader 、StreamWriter：用来操作字符的<blockquote>
<p>方法：Read()、ReadLine()….</p>
</blockquote>
</li>
</ul>
<h2><span id="filestream的使用">FileStream的使用</span></h2><p>FlieStream用来操作<strong>字节</strong></p>
<p><strong>创建FileStream对象：</strong></p>
<p><code>FileStream fs = new FileStream(path,opreateFile,opreateData);</code></p>
<blockquote>
<p>第一个参数path：表示要操作的文件的路径<br><br>第二个参数opreateFile：表示对文件进行怎么的操作<br><br>第三个参数opreateData：表示对文件中的数据进行怎么样的操作</p>
</blockquote>
<ul>
<li>FileMode.OpenOrCreaate：有文件就打开，没有就创建</li>
<li>FileMode.Append：向文件中追加</li>
<li>FileAccess.Read：读取文件内容</li>
<li>FileAccess.Write：写入文件内容</li>
</ul>
<p><strong>使用FileStream读取：</strong></p>
<ul>
<li>创建一个FileStream对象</li>
</ul>
<p><code>FileStream fsR = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Read)；</code></p>
<blockquote>
<p>Path为读取的文件存储的地址</p>
</blockquote>
<ul>
<li>创建缓存区（字节数组）</li>
</ul>
<p><code>byte[] buffer = new buffer[1024*1024*2];</code>    </p>
<blockquote>
<p>大小为2M<br>buffer用来缓存读取到的一定量的字节数，每次读取文件时，只占用这么大的内存</p>
</blockquote>
<ul>
<li>从流中读取数据，返回值为int类型</li>
</ul>
<p><code>int r = fsR.Read(buffer,0,buffer.Length)</code></p>
<blockquote>
<p>从流中读取字节块并将数据写入给定的缓存区<br><br>返回值为int类型，表示真实读到的字节数，将读到的数据存储再buffer当中</p>
</blockquote>
<ul>
<li><p>将字节数组转换成字符串</p>
<pre><code>  string str = Encoding.Default.GetString(buffer,0,r)；
  Concole.WriteLine(str);
  Console.ReadKey();
</code></pre></li>
<li><p>关闭流</p>
</li>
</ul>
<p><code>fsR.Close();</code></p>
<ul>
<li>释放流</li>
</ul>
<p><code>fsR.Dispose();</code></p>
<p><strong>使用FileStream写入：</strong></p>
<ul>
<li>创建FileStream对象</li>
</ul>
<p><code>FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write);</code></p>
<blockquote>
<p>Path是将要写入的文件地址</p>
</blockquote>
<ul>
<li>将要写入的文件转换成字节</li>
</ul>
<p><code>byte[] buffer = Encoding.Default.GetString(s);</code></p>
<blockquote>
<p>string s = “要写入的内容”;</p>
</blockquote>
<ul>
<li>将文件写入缓存区</li>
</ul>
<p><code>fsW.Write(buffer,0,buffer.Length);</code></p>
<ul>
<li>关闭流</li>
</ul>
<p><code>fsW.Close();</code></p>
<ul>
<li>释放流</li>
</ul>
<p><code>fsW.Dispose();</code></p>
<p><strong>为了避免关闭和释放流文件，可以使用using(){}：</strong></p>
<pre><code>Using(FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write))
{
    string s = “要写入的内容”;
    byte[] buffer = Encoding.Default.GetString(s);
}
</code></pre><h2><span id="streamreader-streamwriter的使用">StreamReader、StreamWriter的使用</span></h2><p>StreamReader和StreamWriter用来操作<strong>字符</strong></p>
<ul>
<li><p>StreamReade读取文件：</p>
<pre><code>  string  ReadLine();   读取文件第一行数据，并以字符串的形式返回
  bool  EndOfStream()：获取一个值，该值表示当前的流位置是否在流的末尾
</code></pre></li>
<li><p>创建StreamReader对象：</p>
<pre><code>  StreamReader sr = new StreamReader(path,读取文件的方式);
  读取文件的方式：Encoding.Default
</code></pre></li>
<li><p>StreamWriter写入文件：</p>
<pre><code>  `Write()`
</code></pre></li>
</ul>
<h1><span id="装箱和拆箱">装箱和拆箱</span></h1><ul>
<li>装箱：将值类型转换为引用类型</li>
<li>拆箱：将引用类型转换为值类型</li>
</ul>
<blockquote>
<p>值类型：int decimal double bool char enum struct<br><br>引用类型：数组 集合 string object 自定义类</p>
</blockquote>
<pre><code>例：
int n = 10;
object o = n;   //装箱
int nn = (int)o;  //拆箱
</code></pre><p>拆箱和装箱很浪费时间，应该避免装箱或拆箱<br>判断两个类型之间是否发生装箱或者装箱，首先要确定这两个类型之间是否存在继承关系：<br>如果存在，则有可能会发生拆箱或者装箱<br>如果不存在，则不会发生装箱或者拆箱</p>
<p>装箱时使用什么数据类型，拆箱时也必须使用该类型</p>
<h1><span id="泛型集合">泛型集合</span></h1><ul>
<li>List&lt;&gt;</li>
</ul>
<p>创建ArrayList，必须引用命名空间：System.Collections</p>
<pre><code>`ArrayList arr = new ArrayList();`
</code></pre><p>ArrayList在存储数据时，容易发生装箱和拆箱</p>
<p>创建List&lt;&gt;不需要引用命名空间<br>    <code>List&lt;int&gt; list = new List&lt;int&gt;();  //集合中只能存放int类型</code></p>
<p><strong>方法：</strong></p>
<ul>
<li>Add()：添加元素    只能添加规定类型的元素</li>
<li>Remove()：移除元素</li>
<li>Reverse()：反转集合</li>
<li>Clear()：清除集合</li>
<li>ToArray()：将集合转换为数组</li>
<li>ContainsKey(Keys)：判断是否包含key值</li>
</ul>
<ul>
<li><p>Dictionary<key,value></key,value></p>
<p>  <code>Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</code></p>
</li>
</ul>
<p>遍历Dictionary中的元素一般用<strong>foreach</strong></p>
<pre><code>foreach(var item in dic.keys)
{
    Console.Write(“{0}-----{1}”,item,dic[item])；

}
</code></pre><p>KeyValuePair：键值对</p>
<pre><code>foreach(KeyValuePair&lt;int,string&gt; item in dic)
{
    Console.Write(“{0}-----{1}”,item.Key,item.Value)；
}
</code></pre><h1><span id="多态">多态</span></h1><blockquote>
<p><strong>概念：让一个对象能够表现出多种的状态（类型）</strong></p>
</blockquote>
<p>实现多态的三种方法：</p>
<ul>
<li><strong>虚方法</strong></li>
</ul>
<p>步骤：</p>
<blockquote>
<ol>
<li>将父类的方法标记为虚方法，使用关键字virtual，作用是可以使这个方法可以被子类重写一遍</li>
<li>在子类的方法前面加override</li>
</ol>
</blockquote>
<ul>
<li><strong>抽象类</strong></li>
</ul>
<p>标记一个类为抽象类，使用关键字abstract<br>抽象类不能创建的对象<br>抽象方法：没有方法体的方法且被abstract修饰的方法<br>  如果一个类继承了抽象类，必须重写抽象类里面的抽象方法，使用关键字override</p>
<p>1、抽象成员必须标记为abstract，并且不能有任何的实现<br>2、抽象成员必须在抽象类中<br>3、抽象类不能实例化<br>4、子类继承抽象类后，必须把父类中所有的抽象成员重写（除非子类也是一个抽象类，可以不重写）<br>5、抽象成员的访问修饰符不能是private<br>6、在抽象类中可以包含实例成员<br>7、抽象类是有构造函数的，虽然不能被实例化<br>8、如果抽象父类的抽象方法中有参数，则继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数；如果抽象父类的抽象方法中有返回值，则子类在重写这个抽象方法时，也必须要有返回值</p>
<p>如果父类中的方法有默认的实现，并且父类需要被实例化，可以考虑父类定义成一个普通类，用虚方法实现多态<br>如果父类中的方法没有默认实现，父类也不需要实例化，则可以将该类定义成抽象类</p>
<p>+<strong> 接口</strong></p>
<h1><span id="访问修饰符">访问修饰符</span></h1><ul>
<li>public：公共的，公开的</li>
<li>private：私有的，只能在当前类的内部访问</li>
<li>protected：受保护的，只能在当前类以及该类的子类中访问</li>
<li>internal：只能在当前项目中访问</li>
<li>protecte internal：protected+internal</li>
</ul>
<p><strong>修饰类的访问修饰符只有两个：public、 internal</strong></p>
<h1><span id="设计模式简单工厂设计模式">设计模式：简单工厂设计模式</span></h1><h1><span id="序列化和反序列化">序列化和反序列化</span></h1><ul>
<li>序列化：将对象转换为二进制</li>
<li>反序列化：将二进制转换为对象</li>
</ul>
<p>作用：传输数据</p>
<ul>
<li>序列化对象：BinaryFormatter</li>
<li>序列化方法：Serialize()</li>
<li>反序列化方法：Deserialize()</li>
</ul>
<p>序列化和反序列化需要与流结合使用：</p>
<ol>
<li>将要序列化的对象所在的类标记为可以序列化，使用 [Serializable]</li>
<li>创建序列化对象BinaryFormatter bf = new BinaryFormatter();</li>
<li>序列化：调用Serialize(写入的流对象,需要序列化的对象)</li>
<li>反序列化：调用Deserialize(读取的流对象)</li>
</ol>
<h1><span id="guid">Guid</span></h1><p>Guid.NewGuid()：能创建一个独一无二的ID<br>string s = Guid.NewGuid().ToString()；</p>
<h1><span id="接口">接口</span></h1><ul>
<li>单继承：一个类只能有一个接口</li>
<li>多接口：一个类可以有多个接口</li>
</ul>
<p>定义接口：</p>
<pre><code>[public] interface 接口名称
{
    接口成员;
}
</code></pre><ul>
<li>接口中不能有实例方法；</li>
<li>抽象类中可以有抽象方法，也可以有实例方法；</li>
<li>接口中的成员默认为public，普通的类中的成员默认为private</li>
</ul>
<blockquote>
<p>子类必须重写抽象类中的抽象方法，重写方法使用关键字override<br><br>子类必须实现接口中的抽象方法，不需要使用关键字override</p>
</blockquote>
<ol>
<li>接口是一种规划，只要一个类继承了一个接口，就必须实现接口中的所有成员</li>
<li>接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为public，不能修改</li>
<li>接口中只能由方法、属性、索引器、事件，不能有字段和构造函数</li>
<li>接口与接口之间可以继承，并且可以多继承</li>
<li>接口不能继承类，类可以继承接口（接口只能继承于接口，类既可以继承接口，也可以继承类）</li>
<li>一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA，那么语法上A必须写在IA的前面，因为类是单继承的</li>
<li>显示实现接口：目的是解决方法的重名问题。当继承的接口中的方法和参数一模一样时，用显示的实现接口，尽量不要接口里的方法名字一个方法</li>
<li>当一个抽象类实现接口时，需要抽象类的子类去实现接口</li>
<li>接口的命名：一般以I开头，以able结尾</li>
<li>接口中可以有返回值或者参数</li>
</ol>
<p>实现接口中的方法用：void 接口名.方法(){}</p>
<pre><code>例子：
void IEatable.Eat(){}
</code></pre><p><strong>多态：一个变量表现出多种状态</strong><br><br><strong>继承：声明一个父类，展示多个子类的特性</strong></p>
<p>只要一个类，继承或者实现就可以这样写<br>还有一个虚方法也可以这样写</p>
<p><code>Person p = new Student();</code></p>
<p><strong>抽象类和接口都不允许创建对象</strong><br><strong>静态类也不能创建对象</strong></p>
<h1><span id="值传递和引用传递">值传递和引用传递</span></h1><ul>
<li>值类型：int、double、decimal、bool、char、enum、struct  都继承于valueType</li>
<li>引用类型：string 数组 集合 自定义类 object 接口 </li>
</ul>
<blockquote>
<p>值传递：值类型在赋值的时候，传递的是值本身<br><br>引用类型：引用类型在赋值的时候，传递的是引用（地址）</p>
</blockquote>
<h1><span id="重写父类中的方法">重写父类中的方法</span></h1><ul>
<li>Tostring()</li>
<li>Equals()</li>
</ul>
<h1><span id="md5加密">MD5加密</span></h1><p>密码的保存方式：</p>
<ul>
<li>明文保持</li>
<li>MD5值保持</li>
</ul>
<blockquote>
<p>MD5本质上就是一个算法，且算法是不可逆的</p>
</blockquote>
<p><strong>使用步骤：</strong></p>
<ol>
<li><p>创建MD5对象</p>
<ul>
<li>MD5是一个抽象类，但是类中有2个静态的方法</li>
<li>MD5 md = MD5.Create();  创建MD5对象</li>
</ul>
</li>
<li><p>调用ComputeHash(string str)，返回值为一个字节数组</p>
</li>
<li><p>将字节数组转换成字符串 Encoding.Default.GetString(byte)</p>
</li>
</ol>
<h1><span id="encoding类">Encoding类</span></h1><ul>
<li><p>将字符串转换为字节数组</p>
<p>  <code>Encoding.Default.GetBytes(string str);</code></p>
</li>
<li><p>将字节数组转换为字符串</p>
<p>  <code>Encoding.Default.GetString(byte[] by)</code></p>
</li>
</ul>
<p>Default为默认的读取方式，还可以换成UFT-8、Unicode…</p>
<ul>
<li>ToString()：是什么就转换成什么</li>
<li>GetString()：转换成有意义的字符串</li>
</ul>
<h1><span id="密封类和部分类">密封类和部分类</span></h1><ul>
<li>partial：表示部分类，表示一个类的一部分，各个部分组成一个类。</li>
<li>sealed：表示密封类，被关键字sealed修饰的类表示这个类不能被继承，但可以继承其他类</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C#</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/24/dotNet学习阶段一/" rel="next" title="C#学习阶段一">
                <i class="fa fa-chevron-left"></i> C#学习阶段一
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/24/dotNet学习阶段三/" rel="prev" title="C#学习阶段三">
                C#学习阶段三 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="chenia">
            
              <p class="site-author-name" itemprop="name">chenia</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenia" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:cheniavip@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">常量\枚举\结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.2.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.3.</span> <span class="nav-text">枚举类型与int类型和string类型之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">1.4.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">3.</span> <span class="nav-text">变量的作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">4.</span> <span class="nav-text">out参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">5.</span> <span class="nav-text">ref 参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">6.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">7.</span> <span class="nav-text">params 参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">8.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">9.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">10.</span> <span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">11.</span> <span class="nav-text">修饰符  private</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">12.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">12.1.</span> <span class="nav-text">三种属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">13.</span> <span class="nav-text">构造函数（构造方法）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">14.</span> <span class="nav-text">值类型和引用类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">15.</span> <span class="nav-text">静态和非静态的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">16.</span> <span class="nav-text">垃圾回收期和析构函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">17.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">18.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">19.</span> <span class="nav-text">new 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">20.</span> <span class="nav-text">里氏转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">21.</span> <span class="nav-text">as/is 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">22.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">22.1.</span> <span class="nav-text">ArrayList：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">22.2.</span> <span class="nav-text">集合的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">22.3.</span> <span class="nav-text">Hashtable</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">23.</span> <span class="nav-text">var 推断类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">24.</span> <span class="nav-text">File类 静态类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">25.</span> <span class="nav-text">导入命名空间的快捷方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">26.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">27.</span> <span class="nav-text">Directory类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">28.</span> <span class="nav-text">path类 静态类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">29.</span> <span class="nav-text">文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">29.1.</span> <span class="nav-text">FileStream的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null"><span class="nav-number">29.2.</span> <span class="nav-text">StreamReader、StreamWriter的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">30.</span> <span class="nav-text">装箱和拆箱</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">31.</span> <span class="nav-text">泛型集合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">32.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">33.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">34.</span> <span class="nav-text">设计模式：简单工厂设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">35.</span> <span class="nav-text">序列化和反序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">36.</span> <span class="nav-text">Guid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">37.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">38.</span> <span class="nav-text">值传递和引用传递</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">39.</span> <span class="nav-text">重写父类中的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">40.</span> <span class="nav-text">MD5加密</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">41.</span> <span class="nav-text">Encoding类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">42.</span> <span class="nav-text">密封类和部分类</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenia</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">13.8k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
