<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C#,">





  <link rel="alternate" href="/atom.xml" title="Chenia's Blog" type="application/atom+xml">






<meta name="description" content="常量\枚举\结构常量 定义一个常量 ：const 类型 常量名 = 常量值；  枚举 定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举  确定数量、确定值的几个取值可以使用枚举 语法： [public] enum 枚举名 {     值1；     值2；     ……. } 注意：  枚举名的命名规范必须符合Pascal的命名规范 和字符">
<meta name="keywords" content="C#">
<meta property="og:type" content="article">
<meta property="og:title" content="C#学习阶段二">
<meta property="og:url" content="http://yoursite.com/2019/09/24/dotNet学习阶段二/index.html">
<meta property="og:site_name" content="Chenia&#39;s Blog">
<meta property="og:description" content="常量\枚举\结构常量 定义一个常量 ：const 类型 常量名 = 常量值；  枚举 定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举  确定数量、确定值的几个取值可以使用枚举 语法： [public] enum 枚举名 {     值1；     值2；     ……. } 注意：  枚举名的命名规范必须符合Pascal的命名规范 和字符">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-10-15T16:36:05.788Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C#学习阶段二">
<meta name="twitter:description" content="常量\枚举\结构常量 定义一个常量 ：const 类型 常量名 = 常量值；  枚举 定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举  确定数量、确定值的几个取值可以使用枚举 语法： [public] enum 枚举名 {     值1；     值2；     ……. } 注意：  枚举名的命名规范必须符合Pascal的命名规范 和字符">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/24/dotNet学习阶段二/">





  <title>C#学习阶段二 | Chenia's Blog</title>
  








</head>
<script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenia's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Tomorrow is another chance</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/dotNet学习阶段二/">
   
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenia">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenia's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C#学习阶段二</h1>
        

        <div class="post-meta">
		  
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T13:33:18+08:00">
                2019-09-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-10-16T00:36:05+08:00">
                2019-10-16
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="常量-枚举-结构"><a href="#常量-枚举-结构" class="headerlink" title="常量\枚举\结构"></a>常量\枚举\结构</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><blockquote>
<p><strong>定义一个常量 ：<code>const</code> 类型 常量名 = 常量值；</strong></p>
</blockquote>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><blockquote>
<p><strong>定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举</strong></p>
</blockquote>
<p>确定数量、确定值的几个取值可以使用枚举</p>
<p><strong>语法：</strong></p>
<pre><code>[public] enum 枚举名
{
    值1；
    值2；
    …….
}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>枚举名的命名规范必须符合<code>Pascal</code>的命名规范</li>
<li><p>和字符串比，用枚举的好处就是限定了变量的取值范围</p>
<blockquote>
<p>例：</p>
</blockquote>
<pre><code>    enum Gender{male,female}
      enum Status{Online,offline,hidden};
</code></pre><blockquote>
<p>用法：</p>
</blockquote>
<pre><code>  Status s  s =  Status.online;
</code></pre></li>
</ul>
<h2 id="枚举类型与int类型和string类型之间的转换"><a href="#枚举类型与int类型和string类型之间的转换" class="headerlink" title="枚举类型与int类型和string类型之间的转换"></a>枚举类型与int类型和string类型之间的转换</h2><blockquote>
<p>枚举类型和<code>int</code>类型相互兼容，所以两种类型可以通过强制类型转换的语法相互转换，枚举类型的默认值是从0开始的。</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><strong>作用：可以一次性声明不同类型的变量</strong></p>
<p><strong>语法：</strong></p>
<pre><code>[public] struct 结构名
{
    结构成员;
}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>结构名的命名规范必须符合,<code>Pascal</code>的命名规范</li>
<li>写在命名空间下</li>
<li>结构体内的不叫变量，叫字段，字段的命名习惯在前面加下划线</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote>
<p><strong>定义一个数组：数组类型[] 数组名 = new 数组类型[数组长度];</strong></p>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>数组的长度一旦声明了，就不能再改变了</li>
<li>数组里存储的只能是同一种数据类型</li>
</ul>
<p>声明数组的4种方式：</p>
<pre><code>int[] l1 = new int[4];//只定义了一个数组，未赋
int[] l2 = { 8, 2, 1, 4, 7, 6, 5, 9, 3};
int[] l3 = new int[4] { 1, 2, 3, 4 };
int[] l4 = new int[] { 1, 2, 3, 4 };
</code></pre><h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><blockquote>
<p><strong>一般变量的作用范围为定义时所在的大括号到结束时的大括号的范围内</strong></p>
</blockquote>
<ul>
<li>局部变量</li>
<li>全局变量：作用范围为全类，必须为<code>static</code>，且在<code>class</code>后面定义；</li>
</ul>
<h1 id="out参数"><a href="#out参数" class="headerlink" title="out参数"></a>out参数</h1><blockquote>
<p><strong><code>out</code>参数可以帮助我们在一个方法中返回多个值，不限类型</strong></p>
</blockquote>
<p><strong>语法：</strong></p>
<pre><code>int s;
调用ze(out s)
被调用ze(out int s){….}
或者 
调用 ze(out int s)
被调用ze(out int s){….}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li><code>out</code>参数必须在方法内赋值</li>
<li>调用者内必须传入：<code>out</code> 变量名</li>
<li>被调用者内定义<code>out</code> 数据类型 变量名</li>
</ul>
<h1 id="ref参数"><a href="#ref参数" class="headerlink" title="ref参数"></a>ref参数</h1><blockquote>
<p><strong><code>ref</code>参数是将一个变量以参数的形式带到一个方法中进行改变，改变完成后，再将改变后的值带出来。</strong></p>
</blockquote>
<pre><code>int s = 0;
调用ze(ref s)
被调用ze(ref int s){….}
</code></pre><p><strong>注意：</strong></p>
<ul>
<li><code>ref</code>参数在方法外必须为其赋值</li>
</ul>
<h1 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h1><blockquote>
<p>可变参数数组<br>作用：将某些值默认加入到数组中</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>这些值的类型必须相同</li>
<li>被<code>params</code>修饰的形参只能做最后一个形参</li>
</ul>
<h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><blockquote>
<p><strong>方法的重载指的是方法名称相同，但是参数不同。</strong></p>
</blockquote>
<ul>
<li>如果参数的个数相同，那么参数的类型就不能相同</li>
<li>如果参数的类型相同，那么参数的个数就不能相同</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>方法的重载和返回值无关</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><blockquote>
<p><strong>面向对象三大特征：封装 继承 多态</strong></p>
</blockquote>
<p><strong>语法：</strong></p>
<pre><code>[访问修饰符]  class  类名
{
    类的成员; //字段、属性、方法

}
</code></pre><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>作用：带来方便，想想遥控器的作用</p>
<p>封装有哪些？</p>
<ul>
<li>类封装了对象</li>
<li>属性封装了字段</li>
<li>方法的多个参数封装成了一个对象</li>
<li>将一堆代码封装到了一个方法中</li>
<li>将一些功能封装到几个类中</li>
<li>将一些具有相同功能的代码封装到了一个程序集中(dll、exe)</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>作用：解决代码冗余</p>
<p>子类继承了父类：</p>
<ul>
<li>子类继承了父类的属性和方法，没有继承私有字段</li>
<li>没有继承父类的构造函数，但是子类继承父类后，必须先创建父类的对象才能使用父类的方法,所以子类会调用父类的无参的构造函数</li>
</ul>
<p><strong>注意</strong></p>
<p>当在父类中重写了有参的构造函数后，默认无参的构造函数就不存在了，此时，子类就不能调用了，解决办法有两种：</p>
<ol>
<li>在父类添加一个无参的构造函数</li>
<li>显示的调用父类的有参的构造函数，使用 :base</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>注意：</strong></p>
<ul>
<li>访问修饰符 <code>public</code> </li>
<li>类名：<code>pascal</code> 要求每个首字母大写</li>
<li>写好一个类之后，需要创建这个类的对象，我们管创建这个类的对象的过程称之为类的实例化,使用关键字<code>new</code></li>
<li>类是不占内存的，对象占内存</li>
</ul>
<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><code>this</code>关键字</h1><blockquote>
<p><strong><code>this</code>代表当前类的  对象</strong></p>
</blockquote>
<p> 作用：</p>
<ul>
<li>代表当前类的对象</li>
<li>显示的调度自己的构造函数</li>
</ul>
<h1 id="base关键字"><a href="#base关键字" class="headerlink" title="base关键字"></a><code>base关键字</code></h1><p>作用：</p>
<ul>
<li>让子类显示的调用父类的构造方法</li>
<li>调用父类中的重名的方法，</li>
</ul>
<p>在继承中，当子类的方法和父类的重名了</p>
<ol>
<li>子类调用自己的方法，则子类同名的方法前加<code>new</code>关键字，隐藏从父类继承的方法</li>
<li>子类调用父类的方法，使用关键字<code>base</code>,base.方法名();</li>
</ol>
<h1 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h1><p>类的成员可以有：</p>
<ul>
<li>字段：存储数据  一般为私有的</li>
<li>属性：保护字段</li>
<li>方法：对象行为</li>
<li>构造函数：初始化对象</li>
</ul>
<h1 id="修饰符-private"><a href="#修饰符-private" class="headerlink" title="修饰符 private"></a>修饰符 <code>private</code></h1><blockquote>
<p>类中的成员如果不加访问修饰符，默认为<code>private</code></p>
<p><code>private</code>表示私有的，只能在当前类的内部访问，出了这个类之后，就访问不到了</p>
</blockquote>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><blockquote>
<p><strong>属性是为了保护字段不被随意的修改</strong></p>
<p><strong>字段的属性本质上是由<code>get</code>/<code>set</code>方法构成  属性的本质就是方法</strong></p>
</blockquote>
<ul>
<li>给字段赋值时，调用<code>set</code>方法</li>
<li>取值时，调用<code>get</code>方法</li>
</ul>
<pre><code>- `Fields`   字段
- `Methods`   方法
- `Properties`  属性

        string   _name
        public string Name
        {
           Get { return _name;}
           Set{ _name = value;}
        }
</code></pre><ul>
<li><p>自动属性：不需要写字段的</p>
<pre><code>  public string Name
  {
      get;
      set;
  }
</code></pre></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>字段是：<code>_name</code>   属性是：<code>Name</code></li>
<li>应该给每个字段都配上属性</li>
</ul>
<h2 id="三种属性"><a href="#三种属性" class="headerlink" title="三种属性"></a>三种属性</h2><ul>
<li>既有<code>get</code>方法也有<code>set</code>方法，称之为可读可写属性</li>
<li>只有<code>get</code>方法没有<code>set</code>方法，称之为只读属性</li>
<li>只有<code>set</code>方法没有<code>get</code>方法，称之为只写属性</li>
</ul>
<h1 id="构造函数（构造方法）"><a href="#构造函数（构造方法）" class="headerlink" title="构造函数（构造方法）"></a>构造函数（构造方法）</h1><blockquote>
<p>构造函数的作用是对对象进行初始化<br>构造函数本质就是一个函数，特殊的函数</p>
</blockquote>
<p><strong>语法:</strong></p>
<pre><code>public 构造函数名()
{
    代码;
}
</code></pre><ul>
<li><code>public</code>必须要</li>
<li>没有返回值<code>void</code>都不需要</li>
<li>构造函数的名称必须与类名相同</li>
</ul>
<p>调用构造函数</p>
<p><strong><code>new</code>的作用</strong>：</p>
<ul>
<li>在堆内存中开辟空间</li>
<li>在开辟的堆空间中创建对象</li>
<li>调用对象的构造函数</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>可以重载</li>
<li>类中默认会有一个无参数的构造函数，当重写了构造函数后，默认的构造函数失效</li>
</ul>
<h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><ul>
<li>值类型：<code>int</code> 、<code>double</code>、 <code>char</code> 、<code>bool</code> 、<code>decimal</code>、 <code>struct</code>、 <code>enum</code></li>
<li>引用类型：<code>string</code> 、<code>数组</code>、 <code>自定义类</code></li>
</ul>
<p><strong>存储数据的地方：堆 栈 静态存储区域:</strong></p>
<ul>
<li>值类型：值类型的值存储在栈中</li>
<li>引用类型：引用类型的值存储在堆中</li>
</ul>
<h1 id="静态和非静态的区别"><a href="#静态和非静态的区别" class="headerlink" title="静态和非静态的区别"></a>静态和非静态的区别</h1><ul>
<li><p><strong>区别：有没有<code>static</code></strong> </p>
<ul>
<li>在非静态类中，可以有静态成员，也可以有非静态成员  </li>
<li>在非静态方法中，可以访问静态成员，也可以访问非静态成员</li>
<li>在静态方法中，只允许访问静态成员</li>
<li>在静态类中，不能出现非静态成员，只能有静态成员</li>
<li>静态在调用前初始化，非静态在实例化对象时初始化</li>
<li>静态成员只初始化一次</li>
</ul>
</li>
<li><p><strong>在调用上的区别：</strong></p>
<ul>
<li>在调用实例成员时，需要使用对象去调用</li>
<li>在调用静态成员时，必须使用类名.静态成员</li>
</ul>
</li>
</ul>
<p><strong>静态类不允许创建对象的，静态类的成员，全部用类名.静态成员</strong></p>
<p><strong>在一个类中，既有静态成员又有非静态成员时，先初始化静态成员，并且只初始化一次，而非静态成员有多少个对象就初始化多少次</strong></p>
<p><strong>在整个项目中，静态成员是资源共享的，只有在整个项目都结束的时候才会释放资源</strong></p>
<p>什么时候用静态类？什么时候用非静态类？</p>
<p>如果类属于工具类（非常常用），可以写成静态类</p>
<blockquote>
<p>类不占内存，但静态类占用内存，占用静态存储区域，静态类的资源共享</p>
<p>静态类应该越少越好</p>
<p>静态类释放资源时，必须等待所有的程序结束的时候才能被释放</p>
</blockquote>
<h1 id="垃圾回收期和析构函数"><a href="#垃圾回收期和析构函数" class="headerlink" title="垃圾回收期和析构函数"></a>垃圾回收期和析构函数</h1><blockquote>
<p><strong><code>GC</code>：gargbage collection</strong></p>
</blockquote>
<ul>
<li>当程序结束后，<code>GC</code>会扫描整个内存，如果有空间没有被指向，则把该空间销毁</li>
<li>析构函数是C语言里回收垃圾的</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>特性：</p>
<ul>
<li>不可变性</li>
</ul>
<p>当给字符串重新赋值时，其实是在内存中重新开辟一块空间存储值。由于字符串的不可变性，当需要给一个字符串进行大量的拼接、赋值等操作时，会产生大量的内存垃圾；可以使用<code>StringBuilder</code></p>
<ul>
<li>暂存池特性</li>
</ul>
<p>给字符串赋值值，先在栈中看有没有该值，如果有就先共享该值</p>
<pre><code>string s1 = &quot;123&quot;;
string s2 = &quot;123&quot;;
</code></pre><p>s2和s1共享栈内存</p>
<p>一切类型都可以调用<code>ToString()</code>方法转换成字符串类型</p>
<p><strong>方法：</strong></p>
<ul>
<li><code>ToCharArrray()</code>：将字符串转换成<code>char</code>类型的数组</li>
<li><code>new string(char[]  chs)</code>：将一个字符数组转换成一个字符串</li>
<li><code>ToUpper</code>：转换成大写</li>
<li><code>ToLower</code>：转换成小写</li>
<li><code>Equals(“要比较的字符串”,StringComparison.OrdinalIgnoreCase)</code>：比较字符串是否相同，忽略大小写;</li>
<li><code>Split</code>：分割字符串，返回一个字符串的数组</li>
<li><code>Split(char[]  ch,StringSplitOptions.RemoveEmptyEntries)</code> ：ch是分割的内容，后面是分割后替代的内容</li>
<li><code>Replace</code>：替代字符串</li>
<li><code>Replace(string oldValue,string newValue)</code>：将字符串中出现的<code>oldValue</code>的地方替换为<code>newValue</code></li>
<li><code>SubString</code>：截取字符串</li>
<li><code>Substring(int startindex)</code>：从位置<code>startIndex</code>开始截取到最后的子字符串</li>
<li><code>SubString(int startindex,int length)</code>：从位置<code>startINdex</code>开始截取长度为<code>length</code>的子字符串，如果长度不够则会报错；</li>
<li><code>Contains(string value)</code>：判断字符串中是否含有子串<code>value</code></li>
<li><code>StartsWith(string value)</code>：判断字符串是否以子串<code>value</code>开始</li>
<li><code>EndsWith(string value)</code>：判断字符串是否以子串<code>value</code>结束</li>
<li><code>IndexOf(string value)</code>：子串<code>value</code>第一次出现的位置</li>
<li><code>IndexOf(strinf value,int startIndex)</code>：例如：<code>value</code>第一次出现的位置是1，找第二个<code>value</code>植时，<code>startIndex</code>需要加1，若找不到时，会返回-1</li>
<li><code>LastIndexOf(string value)</code>：</li>
<li><code>Trim</code>：去掉字符串中的空格</li>
<li><code>Trim()</code>：去掉两边的空格</li>
<li><code>TrimEnd()</code>：去掉后面的空格</li>
<li><code>TrimStart()</code>：去掉前面的空格</li>
<li><code>Join</code>：连接</li>
</ul>
<p><strong>属性：</strong></p>
<ul>
<li><code>Length</code>：查看字符串的长度</li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>当大量进行字符串操作的时候，比如字符串的拼接操作；由于<code>String</code>对象是不可变得，每次使用<code>System.String</code>类中的一个方法时，都会在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。在需要对字符串执行重复修改的情况下，与创建新的String对象相关的系统开销可能非常大。如果要修改字符串而不创建新的对象，则可以使用<code>System.Text.StringBuider</code>类</p>
<p><code>StringBuilder</code>仅仅是拼接字符串的工具，大多数情况下还需要将<code>StringBuilder</code>转换为<code>String</code></p>
<p><strong>方法：</strong></p>
<ul>
<li><code>Append</code>：追加</li>
<li><code>Insert(index,value)</code>:插入</li>
<li><code>ToString</code>:把StringBuilder转换为字符串</li>
<li><code>Replace()</code>:替换</li>
</ul>
<h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p><strong>语法：用 : 跟要继承的类</strong></p>
</blockquote>
<p><strong>为什么要继承？</strong></p>
<blockquote>
<p>将一些类中共同具有的属性和方法单独拿出来封装成一个父类。</p>
</blockquote>
<p>面向对象的三大特征：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong></p>
<p>如果一个类继承了另一个类，则称这个类为<strong>子类</strong>（派生类），被继承的类为<strong>父类</strong>（基类）</p>
<ul>
<li>子类继承父类</li>
</ul>
<blockquote>
<p>子类继承属性和方法</p>
<p>子类不能继承私有字段，不能继承构造函数</p>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>子类并没有继承父类的构造函数，但是会默认的调用父类的无参的构造函数</li>
<li>当在父类中重写了构造函数后，默认的无参构造函数就不存在了，此时，子类就无法调用父类的无参构造函数</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>在子类中重写一个无参的构造函数</li>
<li>让子类调用父类有参的构造函数，使用关键字:<code>base</code></li>
</ul>
<p><strong>继承的两个特性：</strong></p>
<ul>
<li>单根性：一个子类只有一个父类（一个儿子只能有一个爸爸）</li>
<li>传递性：子类可以继承父类的父类</li>
</ul>
<p><code>Object</code>类是一切类型的基类</p>
<h1 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h1><blockquote>
<p>如果子类中的方法和父类重名了，子类若想继续使用该方法，可以在子类的方法内增加关键字<code>new</code>将相同名称的父类的方法隐藏掉，</p>
</blockquote>
<pre><code>public new void 相同名称的方法名()
{…}
</code></pre><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote>
<p>定义：只能创建一个对象</p>
</blockquote>
<p>使用单例模式的步骤：</p>
<ol>
<li>提供一个静态方法，返回一个对象</li>
<li>创建一个单例(字段+属性)</li>
</ol>
<h1 id="里氏转换"><a href="#里氏转换" class="headerlink" title="里氏转换"></a>里氏转换</h1><ul>
<li>子类对象可以赋值给父类（如果有一个地方需要一个父类作为参数，可以用子类代替）</li>
<li>如果这个父类中装的是子类对象，那么可以将这个父类强转为对应的子类对象</li>
</ul>
<p>子类：<code>student</code><br>父类：<code>person</code></p>
<pre><code>Students s = new Student();
Person p = s;
Student ss = (Student)p;
</code></pre><h1 id="as-is-关键字"><a href="#as-is-关键字" class="headerlink" title="as/is 关键字"></a>as/is 关键字</h1><ul>
<li><code>is</code>：判断能否进行类型转换，如果转换成功，返回true，转换失败，返回<code>false</code></li>
<li><code>as</code>: 判断能否进行类型转换，如果转换成功，返回对应的对象，如果转换失败，返回一个<code>null</code></li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><strong>引用命名空间using System.Collections</strong></p>
<ul>
<li><code>ArrayList</code></li>
<li><code>Hashtable</code></li>
<li><code>List&lt;T&gt;</code></li>
<li><code>Dictionary&lt;T,T&gt;</code></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>数组的长度不可改变</li>
<li>集合的长度可以任意改变</li>
</ul>
<h2 id="ArrayList："><a href="#ArrayList：" class="headerlink" title="ArrayList："></a>ArrayList：</h2><p><strong>方法</strong>：</p>
<ol>
<li><p>添加</p>
<ul>
<li><code>Add(value)</code>：添加单个元素</li>
<li><code>AddRange(value)</code>：添加集合或者数组</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li><code>Clear()</code>：删除集合中所有的所有</li>
<li><code>Remove(value)</code>：根据值删除单个元素，如果没有<code>value</code>，程序不报错</li>
<li><code>RemoveAt(index)</code>：根据索引删除单个元素</li>
<li><code>RemoveRange(startIndex,endIndex)</code>：删除指定范围内的元素</li>
</ul>
</li>
<li><p>插入</p>
<ul>
<li><code>Insert(Index,value)</code>：在指定的索引上添加值</li>
<li><code>InsertRange(Index,value)</code>：在指定的索引上添加数组或者集合</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><code>Contains()</code>：判断是否包含</li>
<li><code>Sort()</code>：排序</li>
<li><code>Count</code>：获得长度   数组是<code>Length</code></li>
<li><code>Max()</code>：找出最大值</li>
<li><code>Min()</code>：找出最小值</li>
<li><code>AVG()</code>：求平均值</li>
</ul>
</li>
</ol>
<h2 id="集合的长度"><a href="#集合的长度" class="headerlink" title="集合的长度"></a>集合的长度</h2><ul>
<li><code>Count</code>：集合中实际包含的长度</li>
<li><code>Capcity</code>：集合可以包含的长度</li>
</ul>
<blockquote>
<p>当向集合中添加1个元素时，集合的<code>capcity=4</code></p>
<p>当添加的元素超过4个时，集合的<code>capcity=12</code></p>
</blockquote>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>可以称为<strong>字典</strong>，存储的是<strong>键值对</strong></p>
<blockquote>
<p><strong>在键值对集合中，键一定是唯一的，不能重复，值可以重复</strong></p>
</blockquote>
<p><strong>方法：</strong></p>
<ul>
<li><code>Add(key,value)</code>：添加键值对</li>
<li><code>foreach</code>：循环集合中的元素<blockquote>
<p>如：<code>foreach(var  item  in  collection)</code></p>
</blockquote>
</li>
<li><code>keys</code>：获得集合中的键值对    集合[key]=value</li>
<li><code>clear()</code>：清除集合中键值对</li>
<li><code>contains()</code>：是否包含元素</li>
<li><code>containsKey(key)</code></li>
<li><code>containsValue(value)</code></li>
<li><code>remove(key)</code>：根据键移除元素</li>
</ul>
<h1 id="var-推断类型"><a href="#var-推断类型" class="headerlink" title="var 推断类型"></a>var 推断类型</h1><ul>
<li>C#是一门强类型语言，每一种变量必须有一个明确的定义</li>
<li>JavaScript是一门弱类型语言</li>
<li>var 可以通过变量的推断变量的类型</li>
</ul>
<blockquote>
<p><code>GetType()</code>：获得变量的数据类型</p>
</blockquote>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><ul>
<li>说明<ul>
<li>静态类，在System.IO命名空间下</li>
<li>静态类不能创建对象</li>
<li>静态类的成员都是静态成员，可以直接类名.成员调用</li>
<li>File类操作文件的类（不是文件夹)</li>
</ul>
</li>
</ul>
<ul>
<li><p>方法</p>
<ul>
<li><code>Exits(文件地址)</code>：判断文件是否存在</li>
<li><code>Create(文件地址)</code>：创建文件</li>
<li><code>Delete(文件地址)</code>：删除文件</li>
<li><code>Copy(源文件地址,复制文件地址)</code>：复制文件</li>
<li><p><code>Move(源文件地址,复制文件地址)</code>：移动文件</p>
</li>
<li><p><code>OpenFileDialog ofd = new OpenFileDialog();</code></p>
</li>
</ul>
</li>
<li><p>读取文件</p>
<ol>
<li><p><code>String[]  str  =  ReadAllLines(文件地址,读取文件的编码方式)</code>：一行一行读取文件，返回值为字符串数组</p>
<pre><code> Encoding.Default：默认方式
 Encoding.UTF-8
 Encoding.Unicode
</code></pre></li>
<li><p><code>String str = ReadAllText(文件地址,读取文件的编码方式)</code>：读取整个文本，返回值为字符串</p>
<p> <code>ReadAllLines()</code>和<code>ReadAllText()</code>只能读取txt文件</p>
</li>
</ol>
</li>
</ul>
<pre><code>3. `byte[] buffer = ReadAllBytes(文件地址)`;buffer里存的都是数字，需要将buffer转换成字符串，使用`string  str  =Enconding.Default.GetString(buffer);`

    `ReadAllBytes()`可以操作任何格式的文件

        Enconding.Default.GetString();
        Enconding.UTF-8.GetString();
        Enconding.Unicode.GetString();
        Enconding.GetEncoding(“GBK”).GetString();
</code></pre><ul>
<li><p>单位转换</p>
<ul>
<li>1024byte=1kb</li>
<li>1024kb=1M</li>
</ul>
</li>
</ul>
<h1 id="导入命名空间的快捷方式"><a href="#导入命名空间的快捷方式" class="headerlink" title="导入命名空间的快捷方式"></a>导入命名空间的快捷方式</h1><ol>
<li>使用快捷键<code>alt+shift+F10</code></li>
<li>使用鼠标的方式</li>
</ol>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>文本文件编码，文本文件有不同的存储方式，将字符串以什么样的形式保存为二进制，这个就是编码，UTF-8、ASCII、Unicode等，如果出现乱码一般就是编码的问题，文本文件相关的函数一般都有Encoding类型的参数，取得编码的方式：<code>Encoding.Default</code>、<code>Encoding.UTF8</code>、<code>Encoding.GetEncoding(“GBK”)</code></p>
<blockquote>
<p>乱码的原因：保持文件所采取的编码格式与打开文件的编码格式不一致</p>
</blockquote>
<p>输出<code>Encoding.GetEncodings()</code>，所有的编码</p>
<p><strong>常用的静态方法：</strong></p>
<ul>
<li><code>void  AppendAllText(string path,string contents,编码方式)</code>：将文本<code>contents</code>附加到文件<code>path</code>中</li>
<li><code>bool  Exists(string path)</code>：判断文件<code>path</code>是否存在</li>
<li><code>string[]  ReadAllLines(string path)</code>：读取文本文件到字符串数组中</li>
<li><code>string  ReadAllText(string path)</code>：读取文本文件到字符串中</li>
<li><code>void  WriteAllText(string path,string contents)</code>：将文本<code>contents</code>保持到文件<code>path</code>中，会覆盖旧内容</li>
<li><code>void  WriteAllLines(string path,string[] contents)</code>：将字符串数组逐行保存到文件<code>path</code>中，会覆盖旧内容</li>
</ul>
<h1 id="Directory类"><a href="#Directory类" class="headerlink" title="Directory类"></a>Directory类</h1><ul>
<li><p>说明</p>
<ul>
<li><code>Directory</code>类，操作文件夹</li>
<li><code>Directory</code>类是一个静态类，在<code>System.IO</code>命名空间下</li>
<li>静态类不能创建对象</li>
<li>静态类的成员全部为静态成员，直接类名调用</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><code>CreateDirectory(string path)</code>：创建文件夹</li>
<li><code>Delete(string path,true)</code>：删除文件夹 </li>
<li><code>Move(string oldpath,string newpath)</code>：剪切文件夹</li>
<li><code>String[]  path  =  GetFiles(string path,匹配项)</code>：获得文件夹下与匹配项相同的所有文件</li>
</ul>
</li>
</ul>
<h1 id="Path类"><a href="#Path类" class="headerlink" title="Path类"></a>Path类</h1><ul>
<li><p>说明</p>
<ul>
<li><code>Path</code>类，操作文件路径的</li>
<li><code>Path</code>类是一个静态类，在<code>System.IO</code>命名空间下</li>
<li>静态类不能创建对象</li>
<li>静态类的成员全部为静态成员，直接类名调用</li>
</ul>
</li>
</ul>
<ul>
<li><p>方法</p>
<ul>
<li><code>GetFileName()</code>：获得文件名   </li>
<li><code>GetFileNameWithoutExtension()</code>：获得除去拓展名的文件名  </li>
<li><code>GetExtension()</code>：获得文件的拓展名</li>
<li><code>GetDirectoryName()</code>：获取文件夹名</li>
<li><code>GetFullPath()</code>：获取绝对路径</li>
<li><code>Combine(params,path)</code>：连接路径</li>
</ul>
</li>
</ul>
<h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><ul>
<li><p>说明   </p>
<ul>
<li><code>File</code>类的弊端：读写速度太慢，只能读写小文件，因为它是将文件一次性读写出来的</li>
<li><p>文件流读写文件时，每次只占用规定的缓存区大小</p>
</li>
<li><p>文件流有：<code>FileStream</code>、<code>StreamReader</code>、<code>StreamWriter</code></p>
</li>
</ul>
</li>
<li><p><code>FileStream</code>：用来操作字节的</p>
<blockquote>
<p>方法：<code>Read()</code>、<code>Write()</code>…</p>
</blockquote>
</li>
<li><p><code>StreamReader</code> 、<code>StreamWriter</code>：用来操作字符的</p>
<blockquote>
<p>方法：<code>Read()</code>、<code>ReadLine()</code>…</p>
</blockquote>
</li>
</ul>
<h2 id="FileStream的使用"><a href="#FileStream的使用" class="headerlink" title="FileStream的使用"></a>FileStream的使用</h2><p><code>FlieStream</code>用来操作<strong>字节</strong></p>
<ul>
<li><p>创建<code>FileStream</code>对象</p>
<p>  <code>FileStream fs = new FileStream(path,opreateFile,opreateData);</code></p>
<ul>
<li>第一个参数<code>path</code>：表示要操作的文件的路径</li>
<li>第二个参数<code>opreateFile</code>：表示对文件进行怎么的操作</li>
<li><p>第三个参数<code>opreateData</code>：表示对文件中的数据进行怎么样的操作</p>
<ul>
<li><code>FileMode.OpenOrCreaate</code>：有文件就打开，没有就创建</li>
<li><code>FileMode.Append</code>：向文件中追加</li>
<li><code>FileAccess.Read</code>：读取文件内容</li>
<li><code>FileAccess.Write</code>：写入文件内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用<code>FileStream</code>读取</p>
<ol>
<li><p>创建一个<code>FileStream</code>对象</p>
<p> <code>FileStream fsR = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Read)；</code></p>
<blockquote>
<p><code>path为</code>读取的文件存储的地址</p>
</blockquote>
</li>
<li><p>创建缓存区（字节数组）</p>
<p> <code>byte[] buffer = new buffer[1024*1024*2];</code> </p>
<blockquote>
<p>大小为2M，<code>buffer</code>用来缓存读取到的一定量的字节数，每次读取文件时，只占用这么大的内存</p>
</blockquote>
</li>
<li><p>从流中读取数据，返回值为<code>int</code>类型</p>
<p> <code>int r = fsR.Read(buffer,0,buffer.Length)</code></p>
<blockquote>
<p>从流中读取字节块并将数据写入给定的缓存区，返回值为<code>int</code>类型，表示真实读到的字节数，将读到的数据存储再<code>buffer</code>当中</p>
</blockquote>
</li>
<li><p>将字节数组转换成字符串</p>
<pre><code> string str = Encoding.Default.GetString(buffer,0,r)；
 Concole.WriteLine(str);
 Console.ReadKey();
</code></pre></li>
<li><p>关闭流</p>
<p> <code>fsR.Close();</code></p>
</li>
<li><p>释放流</p>
<p> <code>fsR.Dispose();</code></p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>使用<code>FileStream</code>写入</p>
<ol>
<li><p>创建<code>FileStream</code>对象</p>
<p> <code>FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write);</code></p>
<blockquote>
<p><code>path</code>是将要写入的文件地址</p>
</blockquote>
</li>
<li><p>将要写入的文件转换成字节</p>
<p> <code>byte[] buffer = Encoding.Default.GetString(s);</code></p>
<blockquote>
<p>string s = “要写入的内容”;</p>
</blockquote>
</li>
<li><p>将文件写入缓存区</p>
<p> <code>fsW.Write(buffer,0,buffer.Length);</code></p>
</li>
<li><p>关闭流</p>
<p> <code>fsW.Close();</code></p>
</li>
<li><p>释放流</p>
<p> <code>fsW.Dispose();</code></p>
</li>
</ol>
</li>
</ul>
<p><strong>为了避免频繁的关闭和释放流文件，可以使用<code>using(){}</code>：</strong></p>
<pre><code>Using(FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write))
{
    string s = “要写入的内容”;
    byte[] buffer = Encoding.Default.GetString(s);
}
</code></pre><h2 id="StreamReader、StreamWriter的使用"><a href="#StreamReader、StreamWriter的使用" class="headerlink" title="StreamReader、StreamWriter的使用"></a>StreamReader、StreamWriter的使用</h2><p><code>StreamReade</code>r和<code>StreamWriter</code>用来操作<strong>字符</strong></p>
<ul>
<li><p><code>StreamReade</code>读取文件</p>
<pre><code>  string  ReadLine();   读取文件第一行数据，并以字符串的形式返回
  bool  EndOfStream()：获取一个值，该值表示当前的流位置是否在流的末尾
</code></pre></li>
<li><p>创建<code>StreamReader</code>对象</p>
<pre><code>  StreamReader sr = new StreamReader(path,读取文件的方式);
  读取文件的方式：Encoding.Default
</code></pre></li>
<li><p><code>StreamWriter</code>写入文件</p>
<pre><code>  Write()
</code></pre></li>
</ul>
<h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><ul>
<li>装箱：将值类型转换为引用类型</li>
<li><p>拆箱：将引用类型转换为值类型</p>
<blockquote>
<p>值类型：<code>int</code>、<code>decimal</code>、<code>double</code>、<code>bool</code>、<code>char</code> 、<code>enum</code>、<code>struct</code></p>
<p>引用类型：<code>数组</code>、<code>集合</code>、<code>string</code>、<code>object</code>、<code>自定义类</code></p>
</blockquote>
<pre><code>  例：
  int n = 10;
  object o = n;   //装箱
  int nn = (int)o;  //拆箱
</code></pre></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>拆箱和装箱很浪费时间，应该避免装箱或拆箱</li>
<li><p>判断两个类型之间是否发生装箱或者装箱，首先要确定这两个类型之间是否存在继承关系：<br>如果存在，则有可能会发生拆箱或者装箱<br>如果不存在，则不会发生装箱或者拆箱</p>
</li>
<li><p>装箱时使用什么数据类型，拆箱时也必须使用该类型</p>
</li>
</ul>
<h1 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a>泛型集合</h1><ol>
<li><p>ArrayList 集合</p>
<ul>
<li><p>创建<code>ArrayList</code>，必须引用命名空间：<code>System.Collections</code></p>
<p>  <code>ArrayList arr = new ArrayList();</code></p>
</li>
<li><p><code>ArrayList</code>在存储数据时，容易发生装箱和拆箱</p>
</li>
</ul>
</li>
<li><p>List&lt;&gt; 泛型集合</p>
<ul>
<li><p>创建<code>List&lt;&gt;</code>不需要引用命名空间</p>
<p>  <code>List&lt;int&gt; list = new List&lt;int&gt;();  //集合中只能存放int类型</code></p>
</li>
</ul>
</li>
</ol>
<pre><code>* 方法

    - `Add()`：添加元素    只能添加规定类型的元素
    - `Remove()`：移除元素
    - `Reverse()`：反转集合
    - `Clear()`：清除集合
    - `ToArray()`：将集合转换为数组
    - `ContainsKey(Keys)`：判断是否包含key值
</code></pre><ol>
<li><p>Dictionary<key,value> 字典</key,value></p>
<p> <code>Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</code></p>
<ul>
<li><p>遍历 <code>Dictionary</code>中的元素一般用<strong><code>foreach</code></strong></p>
<pre><code>  foreach(var item in dic.keys)
  {
      Console.Write(“{0}-----{1}”,item,dic[item])；

  }
</code></pre></li>
<li><p>键值对<code>KeyValuePair</code></p>
<pre><code>  foreach(KeyValuePair&lt;int,string&gt; item in dic)
  {

      Console.Write(“{0}-----{1}”,item.Key,item.Value)；
  }
</code></pre></li>
</ul>
</li>
</ol>
<h1 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h1><blockquote>
<p><strong>概念：让一个对象能够表现出多种的状态（类型）</strong></p>
</blockquote>
<p>作用：</p>
<p>把不同的子类对象都当作父类来看用，屏蔽不同子类之间的差异，写出通用的代码，写出通用的方法，以适应需要的不断改变。（子类赋给父类）</p>
<p>实现多态的三种方法：</p>
<ol>
<li><p><strong>虚方法</strong></p>
<p>步骤：</p>
<blockquote>
<ol>
<li>将父类的方法标记为虚方法，使用关键字<code>virtual</code>，作用是可以使这个方法可以被子类重写一遍</li>
<li>在子类的方法前面加<code>override</code></li>
</ol>
</blockquote>
</li>
</ol>
<ol>
<li><p><strong>抽象类</strong></p>
<ul>
<li>标记一个类为抽象类，使用关键字<code>abstract</code></li>
<li>抽象类不能创建的对象</li>
<li><p>抽象方法：没有方法体的方法且被<code>abstract</code>修饰的方法</p>
<ul>
<li><p>如果一个类继承了抽象类，必须重写抽象类里面的抽象方法，使用关键字<code>override</code></p>
<pre><code>1、抽象成员必须标记为abstract，并且不能有任何的实现
2、抽象成员必须在抽象类中
3、抽象类不能实例化
4、子类继承抽象类后，必须把父类中所有的抽象成员重写（除非子类也是一个抽象类，可以不重写）
5、抽象成员的访问修饰符不能是private
6、在抽象类中可以包含实例成员
7、抽象类是有构造函数的，虽然不能被实例化
8、如果抽象父类的抽象方法中有参数，则继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数；如果抽象父类的抽象方法中有返回值，则子类在重写这个抽象方法时，也必须要有返回值
</code></pre></li>
</ul>
<p>如果父类中的方法有默认的实现，并且父类需要被实例化，可以考虑父类定义成一个普通类，用虚方法实现多态<br>如果父类中的方法没有默认实现，父类也不需要实例化，则可以将该类定义成抽象类</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><strong>接口</strong></li>
</ol>
<p>使用关键字：<code>Interface</code></p>
<p>接口的命名一般用<code>I-</code>开头，<code>-able</code>结尾</p>
<p>接口中的成员不允许有修饰符，默认为<code>public</code></p>
<p>如果一个类即继承了类有实现了接口，接口放在后面</p>
<p>一个类可以实现多个接口</p>
<p>显示实现接口，解决方法重名问题</p>
<p><strong>注意：</strong></p>
<p>子类的方法必须和父类的相同（参数+返回值）</p>
<p>虚方法、抽象类、重写方法都不能被static修饰</p>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><ul>
<li><code>public</code>：公共的，公开的，在哪里都可以访问</li>
<li><code>private</code>：私有的，只能在当前类的内部访问</li>
<li><code>protected</code>：受保护的，只能在当前类以及该类的子类中访问</li>
<li><code>internal</code>：只能在当前项目中访问</li>
<li><code>protecte internal</code>：protected+internal</li>
</ul>
<p><strong>修饰类的访问修饰符只有两个：<code>public</code>、 <code>internal</code></strong></p>
<p>一个类不加访问修饰符，默认为<code>internal</code></p>
<p><strong>修饰类中的成员：<code>public</code> 、<code>private</code>、 <code>internal</code>、 <code>protected</code></strong></p>
<p><strong>子类的访问权限不能高于父类的访问权限，否则会暴露父类的成员</strong></p>
<h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><blockquote>
<p>作用：通过索引的形式访问元素，方便操作类中的集合</p>
</blockquote>
<p>和属性类似，本质上就是一个方法</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>用于跨项目的访问</p>
<p>步骤：</p>
<ul>
<li>添加项目的引用</li>
<li>导入(using)命名空间</li>
</ul>
<h1 id="设计模式：简单工厂设计模式"><a href="#设计模式：简单工厂设计模式" class="headerlink" title="设计模式：简单工厂设计模式"></a>设计模式：简单工厂设计模式</h1><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><ul>
<li>序列化：将对象转换为二进制</li>
<li>反序列化：将二进制转换为对象</li>
</ul>
<p>作用：传输数据</p>
<ul>
<li>序列化对象：<code>BinaryFormatter</code></li>
<li>序列化方法：<code>Serialize()</code></li>
<li>反序列化方法：<code>Deserialize()</code></li>
</ul>
<p>序列化和反序列化需要与流结合使用：</p>
<ol>
<li>将要序列化的对象所在的类标记为可以序列化，使用 <code>[Serializable]</code></li>
<li>创建序列化对象<code>BinaryFormatter bf = new BinaryFormatter();</code></li>
<li>序列化：调用<code>Serialize(写入的流对象,需要序列化的对象)</code></li>
<li>反序列化：调用<code>Deserialize(读取的流对象)</code></li>
</ol>
<h1 id="Guid"><a href="#Guid" class="headerlink" title="Guid"></a>Guid</h1><ul>
<li><p>生成ID</p>
<p>  <code>Guid.NewGuid()</code>：能创建一个独一无二的ID</p>
</li>
<li><p>创建</p>
<p>  <code>string s = Guid.NewGuid().ToString();</code>    </p>
</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>单继承：一个类只能有一个接口</p>
<p>多接口：一个类可以有多个接口</p>
<ul>
<li><p>定义接口</p>
<pre><code>  [public] interface 接口名称
  {
      接口成员;
  }
</code></pre><ul>
<li>接口中不能有实例方法；</li>
<li>抽象类中可以有抽象方法，也可以有实例方法；</li>
<li>接口中的成员默认为<code>public</code>，普通的类中的成员默认为<code>private</code></li>
</ul>
</li>
</ul>
<pre><code>&gt;子类必须重写抽象类中的抽象方法，重写方法使用关键字`override`
&gt;
&gt;子类必须实现接口中的抽象方法，不需要使用关键字`override`
</code></pre><ul>
<li><p>说明</p>
<ol>
<li>接口是一种规划，只要一个类继承了一个接口，就必须实现接口中的所有成员</li>
<li>接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为public，不能修改</li>
<li>接口中只能由方法、属性、索引器、事件，不能有字段和构造函数</li>
<li>接口与接口之间可以继承，并且可以多继承</li>
<li>接口不能继承类，类可以继承接口（接口只能继承于接口，类既可以继承接口，也可以继承类）</li>
<li>一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA，那么语法上A必须写在IA的前面，因为类是单继承的</li>
<li>显示实现接口：目的是解决方法的重名问题。当继承的接口中的方法和参数一模一样时，用显示的实现接口，尽量不要接口里的方法名字一个方法</li>
<li>当一个抽象类实现接口时，需要抽象类的子类去实现接口</li>
<li>接口的命名：一般以I开头，以able结尾</li>
<li>接口中可以有返回值或者参数</li>
</ol>
</li>
</ul>
<p><br></p>
<ul>
<li><p>实现接口中的方法用</p>
<p><code>void</code> 接口名.方法(){}</p>
<p>  例子：<br>  void IEatable.Eat(){}</p>
</li>
</ul>
<p><strong>多态：一个变量表现出多种状态</strong><br><strong>继承：声明一个父类，展示多个子类的特性</strong></p>
<p>只要一个类，继承或者实现就可以这样写<br>还有一个虚方法也可以这样写</p>
<p><code>Person p = new Student();</code></p>
<p><strong>抽象类和接口都不允许创建对象</strong><br><strong>静态类也不能创建对象</strong></p>
<h1 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h1><p>存储位置：</p>
<p>值类型存储在栈上</p>
<p>引用类型存储在堆中</p>
<p>类型：</p>
<ul>
<li>值类型：<code>int</code>、<code>double</code>、<code>decimal</code>、<code>bool</code>、<code>char</code>、<code>enum</code>、<code>struct</code>  都继承于<code>valueType</code></li>
<li><p>引用类型：<code>string</code> 数组 集合 自定义类 object 接口 </p>
<blockquote>
<p>值传递：值类型在赋值的时候，传递的是值本身<br><br>引用类型：引用类型在赋值的时候，传递的是引用（地址）</p>
</blockquote>
</li>
</ul>
<p>值类型都隐式派生自System.ValueType</p>
<p>引用类型都派生于System.Object</p>
<h2 id="值传递和引用传递-1"><a href="#值传递和引用传递-1" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><ul>
<li>值传递在赋值的时候，传递的是值本身</li>
<li>引用类型在赋值的时候，传递的是对象的一个引用</li>
</ul>
<h1 id="重写父类中的方法"><a href="#重写父类中的方法" class="headerlink" title="重写父类中的方法"></a>重写父类中的方法</h1><p>常被重写的方法：</p>
<ul>
<li><code>Tostring()</code></li>
<li><code>Equals()</code></li>
</ul>
<h1 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h1><p>密码的保存方式：</p>
<ul>
<li>明文保存</li>
<li><p><code>MD5</code>值保存</p>
<blockquote>
<p><code>MD5</code>本质上就是一个算法，且算法是不可逆的</p>
</blockquote>
</li>
</ul>
<p><strong>使用步骤：</strong></p>
<ol>
<li><p>创建<code>MD5</code>对象</p>
<ul>
<li><code>MD5</code>是一个抽象类，但是类中有2个静态的方法</li>
<li><code>MD5 md = MD5.Create();</code>  创建<code>MD5</code>对象</li>
</ul>
</li>
<li><p>调用<code>ComputeHash(string str)</code>，返回值为一个字节数组</p>
</li>
<li><p>将字节数组转换成字符串 <code>Encoding.Default.GetString(byte)</code></p>
</li>
</ol>
<h1 id="Encoding类"><a href="#Encoding类" class="headerlink" title="Encoding类"></a>Encoding类</h1><ul>
<li><p>将字符串转换为字节数组</p>
<p>  <code>Encoding.Default.GetBytes(string str);</code></p>
</li>
<li><p>将字节数组转换为字符串</p>
<p>  <code>Encoding.Default.GetString(byte[] by)</code></p>
</li>
</ul>
<p><code>Default</code>为默认的读取方式，还可以换成<code>UFT-8</code>、<code>Unicode</code>…</p>
<ul>
<li><code>ToString()</code>：是什么就转换成什么</li>
<li><code>GetString()</code>：转换成有意义的字符串</li>
</ul>
<h1 id="密封类和部分类"><a href="#密封类和部分类" class="headerlink" title="密封类和部分类"></a>密封类和部分类</h1><ul>
<li><code>partial</code>：表示部分类，表示一个类的一部分，各个部分组成一个类。</li>
<li><code>sealed</code>：表示密封类，被关键字<code>sealed</code>修饰的类表示这个类不能被继承，但可以继承其他类</li>
</ul>
<h1 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h1><blockquote>
<p>Person p = new Person(){Name = “chenia”,Age = 10,Gender = ;’男’};</p>
</blockquote>
<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><blockquote>
<p>作用：把一个方法作为参数传递给另一个方法，该方法为委托类型</p>
</blockquote>
<p>委托就是指向一个方法</p>
<p><strong>语法：</strong></p>
<ol>
<li><p>在类的外面声明一个委托，关键字delegate(必须和指向的方法具有相同的签名)</p>
<pre><code> public delegate void Test(string name);
</code></pre></li>
<li><p>调用委托</p>
<ul>
<li>创建委托对象  </li>
</ul>
</li>
</ol>
<h1 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h1><p>lamda表达式本质上就是一个匿名函数</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C#</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/24/dotNet学习阶段一/" rel="next" title="C#学习阶段一">
                <i class="fa fa-chevron-left"></i> C#学习阶段一
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/24/dotNet学习阶段三/" rel="prev" title="C#学习阶段三">
                C#学习阶段三 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="chenia">
            
              <p class="site-author-name" itemprop="name">chenia</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenia" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:cheniavip@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#常量-枚举-结构"><span class="nav-number">1.</span> <span class="nav-text">常量\枚举\结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量"><span class="nav-number">1.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">1.2.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举类型与int类型和string类型之间的转换"><span class="nav-number">1.3.</span> <span class="nav-text">枚举类型与int类型和string类型之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构"><span class="nav-number">1.4.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量的作用域"><span class="nav-number">3.</span> <span class="nav-text">变量的作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#out参数"><span class="nav-number">4.</span> <span class="nav-text">out参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ref参数"><span class="nav-number">5.</span> <span class="nav-text">ref参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#params参数"><span class="nav-number">6.</span> <span class="nav-text">params参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法的重载"><span class="nav-number">7.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象"><span class="nav-number">8.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">8.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">8.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">8.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this关键字"><span class="nav-number">9.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#base关键字"><span class="nav-number">10.</span> <span class="nav-text">base关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类成员"><span class="nav-number">11.</span> <span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#修饰符-private"><span class="nav-number">12.</span> <span class="nav-text">修饰符 private</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性"><span class="nav-number">13.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#三种属性"><span class="nav-number">13.1.</span> <span class="nav-text">三种属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数（构造方法）"><span class="nav-number">14.</span> <span class="nav-text">构造函数（构造方法）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#值类型和引用类型"><span class="nav-number">15.</span> <span class="nav-text">值类型和引用类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态和非静态的区别"><span class="nav-number">16.</span> <span class="nav-text">静态和非静态的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收期和析构函数"><span class="nav-number">17.</span> <span class="nav-text">垃圾回收期和析构函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">18.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuilder"><span class="nav-number">18.1.</span> <span class="nav-text">StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承-1"><span class="nav-number">19.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-关键字"><span class="nav-number">20.</span> <span class="nav-text">new 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单例模式"><span class="nav-number">21.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#里氏转换"><span class="nav-number">22.</span> <span class="nav-text">里氏转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#as-is-关键字"><span class="nav-number">23.</span> <span class="nav-text">as/is 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合"><span class="nav-number">24.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList："><span class="nav-number">24.1.</span> <span class="nav-text">ArrayList：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合的长度"><span class="nav-number">24.2.</span> <span class="nav-text">集合的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashtable"><span class="nav-number">24.3.</span> <span class="nav-text">Hashtable</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#var-推断类型"><span class="nav-number">25.</span> <span class="nav-text">var 推断类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#File类"><span class="nav-number">26.</span> <span class="nav-text">File类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#导入命名空间的快捷方式"><span class="nav-number">27.</span> <span class="nav-text">导入命名空间的快捷方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编码"><span class="nav-number">28.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Directory类"><span class="nav-number">29.</span> <span class="nav-text">Directory类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Path类"><span class="nav-number">30.</span> <span class="nav-text">Path类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件流"><span class="nav-number">31.</span> <span class="nav-text">文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FileStream的使用"><span class="nav-number">31.1.</span> <span class="nav-text">FileStream的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StreamReader、StreamWriter的使用"><span class="nav-number">31.2.</span> <span class="nav-text">StreamReader、StreamWriter的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#装箱和拆箱"><span class="nav-number">32.</span> <span class="nav-text">装箱和拆箱</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#泛型集合"><span class="nav-number">33.</span> <span class="nav-text">泛型集合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多态-1"><span class="nav-number">34.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问修饰符"><span class="nav-number">35.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引器"><span class="nav-number">36.</span> <span class="nav-text">索引器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">36.1.</span> <span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式：简单工厂设计模式"><span class="nav-number">37.</span> <span class="nav-text">设计模式：简单工厂设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化和反序列化"><span class="nav-number">38.</span> <span class="nav-text">序列化和反序列化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Guid"><span class="nav-number">39.</span> <span class="nav-text">Guid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口"><span class="nav-number">40.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#值传递和引用传递"><span class="nav-number">41.</span> <span class="nav-text">值传递和引用传递</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#值传递和引用传递-1"><span class="nav-number">41.1.</span> <span class="nav-text">值传递和引用传递</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重写父类中的方法"><span class="nav-number">42.</span> <span class="nav-text">重写父类中的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MD5加密"><span class="nav-number">43.</span> <span class="nav-text">MD5加密</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Encoding类"><span class="nav-number">44.</span> <span class="nav-text">Encoding类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#密封类和部分类"><span class="nav-number">45.</span> <span class="nav-text">密封类和部分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象初始化器"><span class="nav-number">46.</span> <span class="nav-text">对象初始化器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#委托"><span class="nav-number">47.</span> <span class="nav-text">委托</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lamda表达式"><span class="nav-number">48.</span> <span class="nav-text">lamda表达式</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenia</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">15.6k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
