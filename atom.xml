<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chenia&#39;s Blog</title>
  
  <subtitle>Tomorrow is another chance</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-24T06:03:16.691Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#学习阶段二</title>
    <link href="http://yoursite.com/2019/09/24/C#%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/09/24/C#学习阶段二/</id>
    <published>2019-09-24T05:33:18.002Z</published>
    <updated>2019-09-24T06:03:16.691Z</updated>
    
    <content type="html"><![CDATA[<p>33、常量\枚举\结构<br>定义一个常量 ：const 类型 常量名 = 常量值；<br>确定数量、确定值的几个取值可以使用枚举<br>语法：<br>[public] enum 枚举名<br>{<br>    值1；<br>    值2；<br>    …….<br>}</p><p>注意：枚举名的命名规范必须符合 Pascal的命名规范<br>定义一个枚举的位置在命名空间或者类里面，一般写在命名空间下，为了能使在 此命名空间下的所有类都可以访问枚举</p><p>enum Gender{male,female}<br> enum Status{Online,offline,hidden};<br>枚举的用法：Status s  s =  Status.online;<br>和字符串比起来，用枚举的好处就是限定了变量的取值范围</p><p>34、枚举类型与int类型和string类型之间的转换<br>枚举类型和int类型相互兼容，所以两种类型可以通过强制类型转换的语法相互转换，枚举类型的默认值是从0开始的。</p><p>35、结构<br>作用：可以一次性声明不同类型的变量<br>语法：<br>[public] struct 结构名<br>{<br>    结构成员;<br>}<br>注意：结构名的命名规范必须符合 Pascal的命名规范<br>      写在命名空间下<br>结构体内的不叫变量，叫字段，字段的命名习惯在前面加下划线</p><p>36、数组<br>语法：<br>数组类型[] 数组名 = new 数组类型[数组长度];<br>注意：数组的长度一旦声明了，就不能再改变了<br>数组里存储的只能是同一种数据类型</p><p>声明数组的4种方式：<br>int[] l1 = new int[4];//只定义了一个数组，未赋<br>int[] l2 = { 8, 2, 1, 4, 7, 6, 5, 9, 3};<br>int[] l3 = new int[4] { 1, 2, 3, 4 };<br>int[] l4 = new int[] { 1, 2, 3, 4 };</p><p>37、变量的作用域<br>一般变量的作用范围为定义时所在的大括号到结束时的大括号的范围内<br>局部变量<br>全局变量：作用范围为全类，必须为static，且在class后面定义；</p><p>38、out参数<br>Out参数可以帮助我们在一个方法中返回多个值，不限类型<br>注意：out参数必须在方法内赋值</p><p>调用者内必须传入：out  变量名<br>被调用者内定义out 数据类型 变量名<br>语法：<br>Int s;<br>调用ze(out s)<br>被调用ze(out int s){….}<br>或者<br>调用 ze(out int s)<br>被调用ze(out int s){….}</p><p>39、ref 参数<br>Ref参数是将一个变量以参数的形式带到一个方法中进行改变，改变完成后，再将改变后的值带出来。<br>注意：ref参数在方法外必须为其赋值</p><p>Int s = 0;<br>调用ze(ref s)<br>被调用ze(ref int s){….}</p><p>40、方法的重载<br>方法的重载指的是方法名称相同，但是参数不同。<br>参数不同：<br>1）、如果参数的个数相同，那么参数的类型就不能相同<br>2）、如果参数的类型相同，那么参数的个数就不能相同</p><p>注意：方法的重载和返回值无关</p><p>41、params 参数<br>可变参数数组<br>作用：将某些值默认加入到数组中<br>注意：这些值的类型必须相同<br>      被params修饰的形参只能做最后一个形参</p><p>42、面向对象<br>面向对象三大特征：继承 封装 多态<br>类是一个抽象的<br>类的语法：<br>[访问修饰符]  class  类名<br>{<br>    类的成员; //字段、属性、方法</p><p>}<br>访问修饰符 public<br>类名：pascal 要求每个首字母大写</p><p>写好一个类之后，需要创建这个类的对象，我们管创建这个类的对象的过程称之为类的实例化   使用关键字new<br>注意：类是不占内存的，对象占内存<br>43、this<br>This代表当前类的  对象 </p><p>44、类成员<br>类的成员可以有：<br>字段：存储数据  一般为私有的<br>属性：保护字段<br>方法：对象行为<br>构造函数：初始化对象</p><p>45、修饰符  private<br>类中的成员如果不加访问修饰符，默认为private<br>Private表示私有的，只能在当前类的内部访问，出了这个类之后，就访问不到了</p><p>46、属性<br>Fields      字段<br>Methods   方法<br>Properties  属性<br>属性是为了保护字段不被随意的修改<br>字段的属性本质上是由get/set方法构成  属性的本质就是方法<br>给字段赋值时，调用set方法<br>取值时，调用get方法</p><p>String   _name<br>Public string Name<br>{<br>    Get { return _name;}<br>    Set{ _name = value;}<br>}<br>注意：字段是：_name   属性是：Name<br>应该给每个字段都配上属性</p><p>三种属性：<br>既有get方法也有set方法，称之为可读可写属性<br>只有get方法没有set方法，称之为只读属性<br>只有set方法没有get方法，称之为只写属性</p><p>47、构造函数（构造方法）<br>构造函数的作用是对对象进行初始化<br>构造函数本质就是一个函数，特殊的函数<br>语法：<br>Public 构造函数名()<br>{<br>    代码;<br>}<br>1、    public必须要<br>2、    没有返回值void都不需要<br>3、    构造函数的名称必须与类名相同</p><p>调用构造函数<br>New的作用：<br>1）    在堆内存中开辟空间<br>2）    在开辟的堆空间中创建对象<br>3）    调用对象的构造函数</p><p>特点：<br>1）    可以重载<br>2）    类中默认会有一个无参数的构造函数，当重写了构造函数后，默认的构造函数失效</p><p>48、值类型和引用类型<br>值类型：int double char bool decimal struct enum<br>引用类型：string 数组 自定义类<br>存储数据的地方：堆 栈 静态存储区域</p><p>值类型：值类型的值存储在栈中<br>引用类型：引用类型的值存储在堆中</p><p>49、静态和非静态的区别<br>区别：有没有static<br>在非静态类中，可以有静态成员，也可以有非静态成员<br>在非静态方法中，可以访问静态成员，也可以访问非静态成员<br>在静态方法中，只允许访问静态成员<br>在静态类中，不能出现非静态成员，只能有静态成员<br>在调用上的区别：<br>1）    在调用实例成员时，需要使用对象去调用<br>2）    在调用静态成员时，必须使用类名.静态成员</p><p>静态类不允许创建对象的，静态类的成员，全部用类名.静态成员</p><p>什么时候用静态类？什么时候用非静态类？<br>如果类属于工具类（非常常用），可以写成静态类</p><p>类不占内存，但静态类占用内存，占用静态存储区域，静态类的资源共享<br>静态类应该越少越好<br>静态类释放资源时，必须等待所有的程序结束的时候才能被释放</p><p>50、垃圾回收期和析构函数<br>GC：gargbage collection<br>当程序结束后，GC会扫描整个内存，如果有空间没有被指向，则把该空间销毁<br>析构函数是C语言里回收垃圾的</p><p>51、字符串<br>字符串具有不可变性：当给字符串重新赋值时，其实是在内存中重新开辟一块空间存储值。<br>由于字符串的不可变性，当需要给一个字符串进行大量的拼接、赋值等操作时，会产生大量的内存垃圾；可以使用StringBuilder</p><p>一切类型都可以调用ToString()方法转换成字符串类型</p><p>字符串的各种方法：<br>ToCharArrray()：将字符串转换成char类型的数组<br>New string(char[]  chs)：将一个字符数组转换成一个字符串<br>Length：查看字符串的长度<br>ToUpper：转换成大写<br>ToLower：转换成小写<br>Equals(“要比较的字符串”,StringComparison.OrdinalIgnoreCase)：比较字符串是否相同，忽略大小写;<br>Split：分割字符串，返回一个字符串的数组<br>Split(char[]  ch,StringSplitOptions.RemoveEmptyEntries ) ：ch是分割的内容，后面是分割后替代的内容<br>Replace：替代字符串<br>Replace(string oldValue,string newValue)：将字符串中出现的oldValue的地方替换为newValue<br>SubString：截取字符串<br>Substring(int startindex)：从位置startIndex开始截取到最后的子字符串<br>SubString(int startindex,int length)：从位置startINdex开始截取长度为length的子字符串，如果长度不够则会报错；<br>Contains(string value)：判断字符串中是否含有子串value<br>StartsWith(string value)：判断字符串是否以子串value开始<br>EndsWith(string value)：判断字符串是否以子串value结束<br>IndexOf(string value)：子串value第一次出现的位置<br>IndexOf(strinf value,int startIndex)：例如：value第一次出现的位置是1，找第二个value植时，startIndex需要加1，若找不到时，会返回-1<br>LastIndexOf(string value)：<br>Trim：去掉字符串中的空格<br>Trim()：去掉两边的空格<br>TrimEnd()：去掉后面的空格<br>TrimStart()：去掉前面的空格<br>Join：连接</p><p>52、继承<br>语法： 用 : 要继承的类<br>为什么要继承：<br>将一些类中共同具有的属性和方法单独拿出来封装成一个父类。<br>面向对象的三大特征：封装 继承 多态</p><p>自动属性：不需要写字段的<br>Public string Name<br>{<br>    get;<br>set;<br>}</p><p>如果一个类继承了另一个类，则称这个类为子类（派生类），被继承的类为父类（基类）。</p><p>子类继承父类：<br>子类继承属性和方法<br>子类不能继承私有字段，不能继承构造函数<br>注意：子类并没有继承父类的构造函数，但是会默认的调用父类的无参的构造函数；当在父类中重写了构造函数后，默认的无参构造函数就不存在了，此时，子类就无法调用父类的无参构造函数<br>解决办法：<br>1）    在子类中重写一个无参的构造函数<br>2）    让子类调用父类有参的构造函数，使用关键字 :base</p><p>继承的两个特性：<br>1）    单根性 一个子类只有一个父类（一个儿子只能有一个爸爸）<br>2）    传递性 子类可以继承父类的父类</p><p>Object类是一切类型的基类</p><p>53、new 关键字<br>如果子类中的方法和父类重名了，子类若想继续使用该方法，可以在子类的方法内增加关键字 new 将相同名称的父类的方法隐藏掉，<br>Public new void 相同名称的方法名(){….  }</p><p>54、this 关键字<br>作用：代表当前类的对象<br>      显示的调度自己的构造函数</p><p>55、里氏转换<br>1）子类对象可以赋值给父类（如果有一个地方需要一个父类作为参数，可以用子类代替）<br>2）如果这个父类中装的是子类对象，那么可以将这个父类强转为对应的子类对象<br>子类：student<br>父类：person<br>Students s = new Student();<br>Person p = s;<br>Student ss = (Student)p;</p><p>56、as/is 关键字<br>is：判断能否进行类型转换，如果转换成功，返回true，转换失败，返回false<br>as: 判断能否进行类型转换，如果转换成功，返回对应的对象，如果转换失败，返回一个null</p><p>57、集合    using System.Collections<br>ArrayList<br>Hashtable<br>List<t><br>Dictionary<t,t></t,t></t></p><p>数组的长度不可改变<br>集合的长度可以任意改变</p><p>ArrayList：</p><p>方法：<br>添加：<br>Add(value)：添加单个元素<br>AddRange(value)：添加集合或者数组<br>删除：<br>Clear()：删除集合中所有的所有<br>Remove(value)：根据值删除单个元素，如果没有value，程序不报错<br>RemoveAt(index)：根据索引删除单个元素<br>RemoveRange(startIndex,endIndex)：删除指定范围内的元素<br>插入：<br>Insert(Index,value)：在指定的索引上添加值<br>InsertRange(Index,value)：在指定的索引上添加数组或者集合<br>其他：<br>Contains()：判断是否包含<br>Sort()：排序<br>Count：获得长度   数组是Length<br>Max()：找出最大值<br>Min()：找出最小值<br>AVG()：求平均值</p><p>58、集合的长度<br>Count：集合中实际包含的长度<br>Capcity：集合可以包含的长度</p><p>当向集合中添加1个元素时，集合的capcity=4；<br>当添加的元素超过4个时，集合的capcity=12；</p><p>59、Hashtable<br>可以称为 字典，存储的是键值对<br>在键值对集合中，键一定是唯一的，不能重复，值可以重复</p><p>方法：<br>Add(key,value)：添加键值对<br>foreach：循环集合中的元素<br>foreach(var  item  in  collection)<br>keys：获得集合中的键值对    集合[key]=value<br>clear()：清除集合中键值对<br>contains()：是否包含元素<br>containsKey(key)<br>containsValue(value)<br>remove(key)：根据键移除元素</p><p>60、var 推断类型<br>C#是一门强类型语言，每一种变量必须有一个明确的定义<br>JavaScript是一门弱类型语言</p><p>GetType()：获得变量的数据类型</p><p>var 可以通过变量的推断变量的类型</p><p>61、File类 静态类    在System.IO命名空间下<br>静态类不能创建对象<br>静态类的成员都是静态成员，可以直接类名.成员调用<br>File类：操作文件的类（不是文件夹）</p><p>OpenFileDialog ofd = new OpenFileDialog();</p><p>File.方法：<br>Exits(文件地址)：判断文件是否存在<br>Create(文件地址)：创建文件<br>Delete(文件地址)：删除文件<br>Copy(源文件地址,复制文件地址)：复制文件<br>Move(源文件地址,复制文件地址)：移动文件<br>读取文件：<br>1）String[]  str  =  ReadAllLines(文件地址,读取文件的编码方式)：一行一行读取文件，返回值为字符串数组<br>Encoding.Default：默认方式<br>Encoding.UTF-8<br>Encoding.Unicode</p><p>2）String str = ReadAllText(文件地址,读取文件的编码方式)：读取整个文本，返回值为字符串<br>ReadAllLines()和ReadAllText()只能读取txt文件</p><p>3）    byte[]  buffer  =  ReadAllBytes(文件地址)<br>buffer里存的都是数字，需要将buffer转换成字符串，使用Enconding.Default.GetString(buffer);<br>string  str  = Enconding.Default.GetString(buffer);<br>ReadAllBytes()可以操作任何格式的文件</p><p>Enconding.Default.GetString();<br>Enconding.UTF-8.GetString();<br>Enconding.Unicode.GetString();<br>Enconding.GetEncoding(“GBK”).GetString();</p><p>1024byte=1kb<br>1024kb=1M</p><p>62、导入命名空间的快捷方式<br>1）使用快捷键 alt+shift+F10<br>2）使用鼠标的方式</p><p>63、编码<br>编码：<br>乱码的原因：<br>保持文件所采取的编码格式与打开文件的编码格式不一致</p><p>文本文件编码，文本文件有不同的存储方式，将字符串以什么样的形式保存为二进制，这个就是编码，UTF-8、ASCII、Unicode等，如果出现乱码一般就是编码的问题，文本文件相关的函数一般都有Encoding类型的参数，取得编码的方式：Encoding.Default、Encoding.UTF8、Encoding.GetEncoding(“GBK”)<br>输出Encoding.GetEncodings()，所有的编码</p><p>常用的静态方法：<br>void  AppendAllText(string path,string contents,编码方式)：将文本contents附加到文件path中<br>bool  Exists(string path)：判断文件path是否存在<br>string[]  ReadAllLines(string path)：读取文本文件到字符串数组中<br>string  ReadAllText(string path)：读取文本文件到字符串中<br>void  WriteAllText(string path,string contents)：将文本contents保持到文件path中，会覆盖旧内容<br>void  WriteAllLines(string path,string[] contents)：将字符串数组逐行保存到文件path中，会覆盖旧内容</p><p>64、Directory类<br>Directory类：操作文件夹<br>Directory类 静态类  在System.IO命名空间下<br>静态类不能创建对象<br>静态类的成员全部为静态成员，直接类名调用</p><p>CreateDirectory(string path)：创建文件夹<br>Delete(string path,true)：删除文件夹<br>Move(string oldpath,string newpath)：剪切文件夹<br>String[]  path  =  GetFiles(string path,匹配项)：获得文件夹下与匹配项相同的所有文件</p><p>65、path类 静态类  在System.IO命名空间下<br>path类：操作路径<br>GetFileName()：获得文件名    ——-1.txt<br>GetFileNameWithoutExtension()：获得除去拓展名的文件名  ———1<br>GetExtension()：获得文件的拓展名<br>GetDirectoryName()：获取文件夹名<br>GetFullPath()：获取绝对路径<br>Combine(params,path)：连接路径</p><p>66、文件流<br>File类的弊端：读写速度太慢，只能读写小文件，因为它是将文件一次性读写出来的<br>文件流读写文件时，每次只占用规定的缓存区大小<br>文件流：FileStream、StreamReader、StreamWriter<br>FileStream：用来操作字节的<br>    方法：Read()、Write()<br>StreamReader 、StreamWriter：用来操作字符的<br>方法：Read()、ReadLine()….</p><p>67、FileStream的使用<br>FlieStream用来操作字节<br>创建FileStream对象：<br>FileStream fs = new FileStream(path,opreateFile,opreateData);<br>第一个参数path：表示要操作的文件的路径<br>第二个参数opreateFile：表示对文件进行怎么的操作<br>FileMode.OpenOrCreaate：有文件就打开，没有就创建<br>FileMode.Append：向文件中追加<br>第三个参数opreateData：表示对文件中的数据进行怎么样的操作<br>FileAccess.Read：读取文件内容<br>FileAccess.Write：写入文件内容</p><p>使用FileStream读取：<br>1）创建一个FileStream对象<br>FileStream fsR = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Read)；<br>Path为读取的文件存储的地址</p><p>2）创建缓存区（字节数组）<br>byte[] buffer = new buffer[1024<em>1024</em>2];    大小为2M<br>buffer用来缓存读取到的一定量的字节数，每次读取文件时，只占用这么大的内存</p><p>3）    从流中读取数据，返回值为int类型<br>从流中读取字节块并将数据写入给定的缓存区<br>int r = fsR.Read(buffer,0,buffer.Length)，返回值为int类型，表示真实读到的字节数，将读到的数据存储再buffer当中</p><p>4）    将字节数组转换成字符串<br>string str = Encoding.Default.GetString(buffer,0,r)；<br>Concole.WriteLine(str);<br>Console.ReadKey();</p><p>5）    关闭流<br>fsR.Close();</p><p>6）    释放流<br>fsR.Dispose();</p><p>使用FileStream写入：<br>1）    创建FileStream对象<br>FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write);<br>Path是将要写入的文件地址</p><p>2）    将要写入的文件转换成字节<br>string s = “要写入的内容”;<br>byte[] buffer = Encoding.Default.GetString(s);</p><p>3）    将文件写入缓存区<br>fsW.Write(buffer,0,buffer.Length);</p><p>4）    关闭流<br>fsW.Close();</p><p>5）    释放流<br>fsW.Dispose();</p><p>为了避免关闭和释放流文件，可以使用using(){}：<br>Using(FileStream fsW = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write))<br>{<br>    string s = “要写入的内容”;<br>byte[] buffer = Encoding.Default.GetString(s);<br>}</p><p>68、StreamReader、StreamWriter的使用<br>StreamReader和StreamWriter用来操作字符<br>StreamReade读取文件：<br>方法：<br>string  ReadLine();   读取文件第一行数据，并以字符串的形式返回<br>bool  EndOfStream()：获取一个值，该值表示当前的流位置是否在流的末尾</p><p>创建StreamReader对象：<br>StreamReader sr = new StreamReader(path,读取文件的方式);<br>读取文件的方式：Encoding.Default</p><p>StreamWriter写入文件：<br>方法：<br>Write():</p><p>69、装箱和拆箱<br>装箱：将值类型转换为引用类型<br>拆箱：将引用类型转换为值类型<br>值类型：int decimal double bool char enum struct<br>引用类型：数组 集合 string object 自定义类</p><p>例：<br>int n = 10;<br>object o = n;   //装箱<br>int nn = (int)o;  //拆箱</p><p>拆箱和装箱很浪费时间，应该避免装箱或拆箱<br>判断两个类型之间是否发生装箱或者装箱，首先要确定这两个类型之间是否存在继承关系：<br>如果存在，则有可能会发生拆箱或者装箱<br>如果不存在，则不会发生装箱或者拆箱</p><p>装箱时使用什么数据类型，拆箱时也必须使用该类型</p><p>70、泛型集合<br>1）List&lt;&gt;<br>创建ArrayList，必须引用命名空间：System.Collections<br>ArrayList arr = new ArrayList();<br>ArrayList在存储数据时，容易发生装箱和拆箱</p><p>创建List&lt;&gt;不需要引用命名空间<br>List<int> list = new List<int>();  //集合中只能存放int类型</int></int></p><p>方法：<br>Add()：添加元素    只能添加规定类型的元素<br>Remove()：移除元素<br>Reverse()：反转集合<br>Clear()：清除集合<br>ToArray()：将集合转换为数组<br>ContainsKey(Keys)：判断是否包含key值<br>2）Dictionary<key,value><br>Dictionary<int,string> dic = new Dictionary<int,string>();</int,string></int,string></key,value></p><p>遍历Dictionary中的元素一般用foreach<br>foreach(var item in dic.keys)<br>{<br>    Console.Write(“{0}——-{1}”,item,dic[item])；</p><p>}</p><p>KeyValuePair：键值对</p><p>foreach(KeyValuePair<int,string> item in dic)<br>{<br>Console.Write(“{0}——-{1}”,item.Key,item.Value)；<br>}</int,string></p><p>71、多态<br>概念：让一个对象能够表现出多种的状态（类型）</p><p>实现多态的三种方法：<br>1）    虚方法<br>步骤：<br>1、将父类的方法标记为虚方法，使用关键字virtual，作用是可以使这个方法可以被子类重写一遍<br>2、在子类的方法前面加override </p><p>2）    抽象类<br>标记一个类为抽象类，使用关键字abstract<br>抽象类不能创建的对象<br>抽象方法：没有方法体的方法且被abstract修饰的方法<br>  如果一个类继承了抽象类，必须重写抽象类里面的抽象方法，使用关键字override</p><p>1、抽象成员必须标记为abstract，并且不能有任何的实现<br>2、抽象成员必须在抽象类中<br>3、抽象类不能实例化<br>4、子类继承抽象类后，必须把父类中所有的抽象成员重写（除非子类也是一个抽象类，可以不重写）<br>5、抽象成员的访问修饰符不能是private<br>6、在抽象类中可以包含实例成员<br>7、抽象类是有构造函数的，虽然不能被实例化<br>8、如果抽象父类的抽象方法中有参数，则继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数；如果抽象父类的抽象方法中有返回值，则子类在重写这个抽象方法时，也必须要有返回值</p><p>如果父类中的方法有默认的实现，并且父类需要被实例化，可以考虑父类定义成一个普通类，用虚方法实现多态<br>如果父类中的方法没有默认实现，父类也不需要实例化，则可以将该类定义成抽象类</p><p>3）    接口</p><p>72、访问修饰符<br>public：公共的，公开的<br>private：私有的，只能在当前类的内部访问<br>protected：受保护的，只能在当前类以及该类的子类中访问<br>internal：只能在当前项目中访问<br>protecte internal：protected+internal</p><p>修饰类的访问修饰符只有两个：public、 internal</p><p>73、设计模式：简单工厂设计模式</p><p>74、序列化和反序列化<br>序列化：将对象转换为二进制<br>反序列化：将二进制转换为对象</p><p>作用：传输数据</p><p>序列化对象：BinaryFormatter<br>序列化方法：Serialize()<br>反序列化方法：Deserialize()</p><p>序列化和反序列化需要与流结合使用：<br>1、    将要序列化的对象所在的类标记为可以序列化，使用 [Serializable]<br>2、    创建序列化对象BinaryFormatter bf = new BinaryFormatter();<br>3、    序列化：调用Serialize(写入的流对象,需要序列化的对象)<br>4、    反序列化：调用Deserialize(读取的流对象)</p><p>75、<br>Guid.NewGuid()：能创建一个独一无二的ID<br>string s = Guid.NewGuid().ToString()；</p><p>76、接口<br>单继承：一个类只能有一个接口<br>多接口：一个类可以有多个接口<br>定义接口：<br>[public] interface 接口名称<br>{<br>    接口成员;<br>}<br>接口中不能有实例方法；<br>抽象类中可以有抽象方法，也可以有实例方法；<br>接口中的成员默认为public，普通的类中的成员默认为private</p><p>子类必须重写抽象类中的抽象方法，重写方法使用关键字override<br>子类必须实现接口中的抽象方法，不需要使用关键字override</p><p>1）接口是一种规划，只要一个类继承了一个接口，就必须实现接口中的所有成员<br>2）接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为public，不能修改<br>3）接口中只能由方法、属性、索引器、事件，不能有字段和构造函数<br>4）接口与接口之间可以继承，并且可以多继承<br>5）接口不能继承类，类可以继承接口（接口只能继承于接口，类既可以继承接口，也可以继承类）<br>6）一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA，那么语法上A必须写在IA的前面，因为类是单继承的<br>7）显示实现接口：目的是解决方法的重名问题。当继承的接口中的方法和参数一模一样时，用显示的实现接口，尽量不要接口里的方法名字一个方法<br>实现接口中的方法用：void 接口名.方法(){}<br>例子：void IEatable.Eat(){}</p><p>8）当一个抽象类实现接口时，需要抽象类的子类去实现接口<br>9）接口的命名：一般以I开头，以able结尾<br>10）接口中可以有返回值或者参数</p><p>多态：一个变量表现出多种状态<br>继承 声明一个父类，展示多个子类的特性</p><p>只要一个类，继承或者实现就可以这样写<br>还有一个虚方法也可以这样写</p><p>Person p = new Student();</p><p>抽象类和接口都不允许创建对象<br>静态类也不能创建对象</p><p>77、值传递和引用传递<br>值类型：int、double、decimal、bool、char、enum、struct  都继承于valueType<br>引用类型：string 数组 集合 自定义类 object 接口 </p><p>值传递：值类型在赋值的时候，传递的是值本身<br>引用类型：引用类型在赋值的时候，传递的是引用（地址）</p><p>78、重写父类中的方法<br>Tostring()<br>Equals()</p><p>79、MD5加密<br>明文保持<br>MD5值保持<br>MD5本质上就是一个算法，且算法是不可逆的<br>使用步骤：<br>1）    创建MD5对象<br>MD5是一个抽象类，但是类中有2个静态的方法<br>MD5 md = MD5.Create();  创建MD5对象<br>2）    调用ComputeHash(string str)，返回值为一个字节数组<br>3）将字节数组转换成字符串 Encoding.Default.GetString(byte)</p><p>80、Encoding类<br>1）将字符串转换为字节数组<br>Encoding.Default.GetBytes(string str);<br>2）将字节数组转换为字符串<br>Encoding.Default.GetString(byte[] by)<br>Default为默认的读取方式，还可以换成UFT-8、Unicode…</p><p>ToString()：是什么就转换成什么<br>GetString()：转换成有意义的字符串</p><p>81、密封类和部分类<br>partial：表示部分类，表示一个类的一部分，各个部分组成一个类。<br>sealed：表示密封类，被关键字sealed修饰的类表示这个类不能被继承，但可以继承其他类</p><p>82、winform窗体应用程序  桌面应用程序开发<br>Winform窗体应用程序是一种智能的客户端技术，交互模式是C/S，要求用户必须安装一个客户端<br>通过它，可以智能的获取数据和显示数据<br>开发包括：<br>1）<br>2）UI设计<br>拖动一个控件就是一个创建对象的过程</p><p>Winform窗体的执行过程：<br>1）</p><p>2）</p><p>3）</p><p>InitializeComponent()：对窗体以及窗体对象进行初始化<br>4）</p><p>对Form1.Designer.cs几乎不操作<br>主要操作： </p><p>快捷键：F4，转到属性<br>属性：<br>窗体的属性：点击窗体，按F4进入窗体的属性设置<br>控件的属性：点击控件，按F4进入控件的属性设置</p><p>83、事件<br>事件：例如单击、双击…</p><p>事件的本质就是一个方法<br>事件要是想执行，必须有人触发它</p><p>注册的默认事件，单击就可以进入方法里，如窗体的加载事件（Load）、按钮的单击事件（Click）</p><p>Object Sender表示触发事件的对象<br>EventArgs e表示执行执行对象的参数和资源</p><p>给控件添加事件<br>选择控件，F4进入属性设置，选择事件，点击任意事件就可以进入事件的方法里</p><p>84、控件<br>TextBox文本框<br>WordWap 自动换行<br>Focus 聚焦<br>Visible 是否可见<br>Clear 清除内容<br>Button 按钮<br>Label 标签<br>Timer 定时器，让一个事件每隔多长事件执行一次</p><p>85、MDI窗体设计<br>主窗体中包含很多的子窗体<br>设置主窗体 IsMdiContainer = true；</p><p>86、OpenFileDialog类</p><p>87、GDI+<br>GDI+（Graphics Device Interface）是一种绘图装置接口，可将应用程序和绘图硬件分隔，让我们能够编写与装置无关的应用程序。它可以让我们不需要注意特定显示装置的详细数据，便可在屏幕或打印机显示信息。我们可以呼叫GDI+类别所提供的方法，然后这些方法会适当呼叫特定的装置驱动程序，而完成绘图。而且与.NET进行了更好的融合。</p><p>GDI+就是画图的</p><p>88、.NET FrameWork框架<br>框架容2部分构成：<br>1）.NET 类库<br>小写的string 和大写的String在编译后，都会映射为String类<br>string 为关键字<br>String 为类名<br>2）CLR Common Language Runtime 公共语言运行时<br>当我们点击F5运行程序时，CLR首先加载所有的类文件到内存中，找到其中的主函数，从上到下，一行一行的执行。<br>基于.Net有很多语言开发，如C# 、C++….   .Net平台实现了一个语言无关性<br>如何实现语言无关性：<br>C#  ===》编译为IL（MSIL） 中间语言 ===》由CLR执行IL </p><p>89、GDI+的坐标系统<br>在GDI+中所采用的坐标系统，x轴和y轴分别是往右往下递增</p><p>90、GDI+的使用<br>1）创建对象<br>Graphics是一个密封类，无法创建对象<br>通过当前窗体创建一个GDI对象：Graphics g = this.CreateGraphics()；<br>2）画图<br>画直线：笔 纸 两个点 颜色 你<br>创建两个点：Point p1 = new Point(50,50);<br>            Point p2 = new Point(100,100);<br>创建一个刷子：Brush类，不能创建对象，直接调用方法<br>创建一个笔：Pen  p = new Pen(Brush.Yellow);<br>画直线：g.DrawLine(pen,p1,p2);</p><p>画矩形：<br>Graphics g = this.CreateGraphics();<br>Size size = new System.Drawing.Size(150,150);<br>Rectangle rec = new Rectangle(new Point(220,220),size);<br>g.DrawRectangle(new Pen(Brushes.Red),rec);</p><p>填充一个矩形：<br>g.FillRectangle(Brushes.Yellow,rec);</p><p>写字：<br>Graphics g = this.CreateGraphics();<br>g.DrawString(“内容”,new Font(“宋体”,FontStyle.Bold,20),Brushes.Red,new Point(240,240));</p><p>91、图形类所在的命名空间<br>System.Drawing：提供了对GDI+基本图形功能的访问的类；<br>System.Drawing.Imaging：提供高级GDI+图像处理功能的类；<br>System.Drawing.Text：提供高级GDI+排版功能，该命名空间中的类允许用户创建和使用多种字体的类；</p><p>92、画验证码<br>承载图片的控件：PictureBox<br>图片大小单位：像素</p><p>画任何东西都要坐标</p><p>1）产生随机数，拼接成字符串<br>2）创建图片，指定高度和宽度  Bitmap bmp = new Bitmap(120,25);<br>3）创建GDI对象，用来画图片的   Graphic g = Graphics.FromImage(bmp);<br>4）申明两个数组，存放字体样式和颜色<br>5）确定随机数的坐标，横坐标必须有间隔  坐标是相当于PictureBox而言<br>6）画线<br>7）画像素颗粒</p><p>93、多线程<br>进程：每一个应用程序都是一个进程<br>进程由多个线程组成的<br>进程类：Process<br>Process.GetProcesses();  获取当前所有的线程<br>Process.kill();  杀掉进程<br>Process.GetCurrentProcess(); 获得当前的进程<br>Process.Start(进程名);  开启一个进程</p><p>主线程：程序写好之后，CPU会分配一个主线程，主线程用来创建窗体、控件</p><p>线程类：Thread<br>产生一个线程的步骤：<br>1）    编写产生线程所要执行的方法   Test<br>2）    引用System.Threading命名空间<br>3）    实例化Thread类，并传入一个指向线程所要运行方法的委托  Thread th = new Thread(Test);<br>4）    调用Thread实例的Start方法，标记该线程可以被CPU执行，但具体的执行时间由CPU决定</p><p>Thread类的重要成员：<br>Start();   启动线程   只是告诉CPU，该线程已经准备好了，启动线程最终由CPU决定<br>Abort();  终止线程     线程一旦被关闭了，就不能再被打开，Abort之后无法再Start<br>Thread.Sleep(1) 静态方法，可以使当前线程停止一段时间运行<br>Name 线程名<br>Thread.CurrentThread 获取当前的线程引用</p><p>前台线程和后台线程<br>前台线程：只有所有的前台线程都关闭才能完成程序关闭<br>后台线程：只要所有的前台线程结束，后台线程自动结束</p><p>th.IsBackgroud = true；设置为后台线程</p><p>跨线程访问   .Net不允许跨线程访问<br>Control.CheckForIllegalCrossThreadCalls = false;     取消对跨线程访问的检查</p><p>关闭其他线程时，需要同时关闭线程里面的其他线程里的东西</p><p>94、Socket网络编程</p><p>Socket负责应用程序之间的通信<br>Socket的英文原义为孔或是插座，作为进程通信机制，。通常也称之为套接字，用于描述IP地址和端口，是一个通信的句柄。</p><p>协议：可以理解为规定沟通用的语言  如：tcp协议 http协议</p><p>Socket相关概念（端口）<br>在Internet上有很多这样的主机，这些主机一般运行了很多个服务软件，同时提供几种服务。每种服务都打开了一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务（应用程序）。例如：http使用80端口  ftp使用21端口  smtp使用25端口</p><p>两种类型的Socket：<br>1）    流式Socket（STREAM）：<br>是一种面向连接的Socket，针对于面向连接的TCP服务应用，安全，但是效率低；（三次握手）<br>2）    数据报式<br>是一种无连接的Socket，对应于无连接的UDP服务应用，不安全（丢失数据、顺序混乱、在接收端要分析重排及要求重发），但效率高</p><p>Socket的通讯过程：<br>服务器端：<br>    申请一个socket<br>    绑定到一个IP地址和一个端口上<br>    开启监听，等待接受连接<br>客户端：<br>    申请一个socket<br>    连接服务器（指明IP和端口号）<br>服务器端接到连接请求后，产生一个新的socket与客户端建立连接并进行通讯，原监听socket继续监听。</p><p>注意：<br>至少要定义一个要连接的远程主机的IP和端口号，端口号必须在1和6553之间，最好在1024以后；<br>要连接的远程主机必须正在监听指定的端口，也就是说无法随意连接远程主机<br>如：<br>IPAddress addr = IPAddress.Parse(“127.0.0.1”);<br>IPEndPoint endp = new IPEndPoint(addr.100001);<br>服务器端先绑定：serverWelcomSocket.Bind(endp);<br>客户端再连接：clientSocket.Connect(endp);</p><p>创建Socket对象：<br>Socket socket = new Socket(IP型号，socket类型，对应的协议);<br>如：<br>Socket socket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);<br>AddressFamily.InterNetwork： IPV4<br>SocketType.Stream：流式Socke<br>ProtocolType.Tcp：对应的TCP协议</p><p>AddressFamily、SocketType、ProtocolType都为枚举类型</p><p>Socket一般应用模式（服务器端和客户端）<br>服务器端的Socket（至少需要2个）：<br>1、    一个负责接收客户端请求连接请求（但不负责与客户端通信）<br>2、每成功接收到一个客户端的连接便在服务端产生一个对应得负责通信的Socket<br>    在接收客户端连接时创建<br>    为每个连接成功的客户端请求在服务端都创建一个对应的Socket<br>客户端的Socket：<br>1、    必须指定要连接的服务端的地址和端口<br>2、    通过创建一个Socket对象来初始化一个到服务器端的TCP连接</p><p>TCP协议的三次握手：<br>1、    Client问Server：你有空嘛？<br>2、    Server回答：有空<br>3、    Client回答：我知道了，我准备发送数据了</p><p>1、    服务端welcoming socket开始监听端口<br>2、    客户端client socket连接服务端指定端口<br>3、    服务端welcoming socket监听到客户端连接，创建connection socket</p><p>95、Socke通信</p><p>监听队列：表示在某个时间点可以连入服务端的最大客户端的数量</p><p>Telnet Client 允许本地计算机连接远程的计算机<br>Telnet Server 允许远程计算机连接本地计算机</p><p>//创建负责监听的socket<br>Socket socketWatch = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);<br>//创建IP和端口<br>// IPAddress ip =IPAddress.Parse(txtServer.Text);  //Parse()讲字符串转换成IP地址<br>IPAddress ip = IPAddress.Any;<br>IPEndPoint port = new IPEndPoint(ip,Convert.ToInt32(txtPort.Text));<br>socketWatch.Bind(port);    //让负责监听的Socket绑定IP地址和端口号<br>socketWatch.Listen(10);     //建立监听队列<br>//负责监听的socket 来接受客户端的连接 创建与客户端通信的socket<br>Socket socketSend = socketWatch.Accept();</p><p>当客户端没有连接时，服务端会一直等待客户端的连接，所以，程序会一直停在这里，窗口卡死，所以，采用多线程的方式执行Listen()方法。</p><p>96、多线程执行带参数的方法</p><p>线程执行的方法中，如果带有参数，那么这个参数必须是object类型<br>在所执行的方法里，将object类型转化成想要的类型</p><p>凡是设计到网络的地方都try…catch</p><p>97、启动另外一个Winform应用程序<br>项目右击——- &gt;调试———- &gt;启动新实例</p><p>98、手动写协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;33、常量\枚举\结构&lt;br&gt;定义一个常量 ：const 类型 常量名 = 常量值；&lt;br&gt;确定数量、确定值的几个取值可以使用枚举&lt;br&gt;语法：&lt;br&gt;[public] enum 枚举名&lt;br&gt;{&lt;br&gt;    值1；&lt;br&gt;    值2；&lt;br&gt;    …….&lt;br&gt;}&lt;
      
    
    </summary>
    
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#学习阶段一</title>
    <link href="http://yoursite.com/2019/09/24/C#%E5%AD%A6%E4%B9%A0%E9%98%B6%E6%AE%B5%E4%B8%80/"/>
    <id>http://yoursite.com/2019/09/24/C#学习阶段一/</id>
    <published>2019-09-24T04:36:13.343Z</published>
    <updated>2019-09-24T06:03:10.275Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="net与c">.net与C</span></h1><ul><li>.net/dotnet：一般指.Net Framework框架，一种平台，一种技术</li><li>C#：一种编程语言，可以开发基于.net平台的应用<br>Java既是一种平台也是一种编程语言<br><blockquote><p>如：工厂提供平台生产笔记本，工厂里有机器 生产屏幕，有机器生产键盘….<br>各种机器组成一个平台，生产笔记本,dotNet就是工厂</p></blockquote></li><li>C#、C++、SQL Server…可以基于dotNet平台可以开发应用程序<br>C#可以开发基于dotNet平台下的桌面应用程序、internet应用程序…<br></li><li>2002年6月22日dotNet正式发布</li></ul><h1><span id="net两种交互模式">.Net两种交互模式</span></h1><ul><li><p>C/S：客户机(Client)/服务器模式(Server)：客户端需要安装专用的客户端软件</p><blockquote><p>如：qq：桌面应用程序</p></blockquote></li><li><p>B/S：浏览器(Browser)/服务器模式(Server)：客户机上只要安装一个浏览器</p><blockquote><p>如：淘宝、京东：Internet应用程序</p></blockquote></li></ul><h1><span id="ide介绍">IDE介绍</span></h1><p>IDE（Integrated Development,集成开发环境）<br>就是开发工具 VS2017 VS2013…..</p><h1><span id="启动vs">启动VS</span></h1><ol><li>双击</li><li>命令行运行敲入：devenv</li></ol><h1><span id="创建项目">创建项目</span></h1><blockquote><p>如：Windows窗体应用程序——桌面应用程序、控制台应用程序</p></blockquote><ul><li>名称：给创建项目起一个名字</li><li>位置：建好的项目的位置</li><li>解决方案名称</li><li>Properties:属性        </li><li>引用</li><li>App.config：配置文件</li><li>以cs结尾的文件统称为 <blockquote><p>如：process.cs</p><h1><span id="类文件">类文件</span></h1></blockquote></li><li>using XXX 引用命名空间  就是using 项目名称<blockquote><p>A公司在开发一个项目projectA，项目中含有一个顾客类<br><br>B公司在开发一个项目projectB，项目中含有一个顾客类<br><br>C公司在开发一个项目projectC，需要A公司的顾客类，也需要B公司的顾客类，则C公司使用命名空间using System A;using System B;</p></blockquote></li><li>namespace  项目名称</li><li>class Process 类 被Class修饰的都叫类</li><li>static void Main(string[] args){} 方法 </li></ul><p><strong>主函数、主方法、入口，一个项目只有一个主方法</strong></p><h1><span id="解决方案项目类">解决方案/项目/类</span></h1><p>简单理解为：<br></p><blockquote><p>解决方案——公司<br><br>项目———部门<br><br>类——-员工</p></blockquote><ul><li>解决方案文件夹</li><li><p>项目文件夹<br></p><blockquote><p>.sln 解决方案文件，包含当前解决方案的信息，可以双击打开<br><br>  .csproj 项目文件，包含当前项目的信息，不可以双击打开</p></blockquote></li><li><p>启动快捷键 F5</p></li><li>生成解决方案 F6<blockquote><p>生成之后：生成解决方案后，有exe文件生成，exe文件成为可执行文件，有运行环境就可以双击打开<br><br>装有.net的运行环境，双击.exe就可以运行</p></blockquote></li></ul><h1><span id="设置">设置</span></h1><ul><li>设置行号</li><li>设置字体—-工具 选项 环境</li><li><p>创建多个项目，设置启动项：解决方法&gt;右键&gt;属性&gt;启动项目</p></li><li><p>高亮显示</p></li><li>项目的加载与卸载 —-右击 卸载/加载</li></ul><h1><span id="vs的快捷键">VS的快捷键</span></h1><ul><li>Ctrl + K + D 快速对齐代码</li><li>Ctrl + J 快速弹出智能提示</li><li>Shift + End Shift + Home</li><li>Ctrl + K + C 注释所选代码</li><li>Ctrl + K + U 取消所选代码</li><li>F1 转到帮助文档</li></ul><h1><span id="注释">注释</span></h1><ul><li>单行注释 //</li><li>多行注释  /<em> ….</em>/</li><li>文档注释   ///….///</li><li>Region/EndRegion  折叠冗余代码</li></ul><h1><span id="变量类型">变量类型</span></h1><p><strong>申明变量语法：变量类型 变量名 = 值；</strong></p><ul><li>整数类型 int  </li><li>小数类型 double </li><li>字符串类型 string</li><li>字符类型 char</li><li>金钱类型 decimal  精度高与double 一般会在值后面加m 如：decimal money = 500000m;</li></ul><blockquote><p><strong>变量的使用过程：必须先声明 再赋值 最后使用</strong><br><br><strong>未使用会有警告线</strong><br><br><strong>变量不允许重复的声明</strong><br><strong>一次声明多个相同类型的变量：变量类型 变量名1, 变量名2, 变量名3, 变量名4</strong></p></blockquote><h1><span id="命名规范">命名规范</span></h1><ol><li>必须以 字母 或 @符号开头，不要以数字开头</li><li>后面可以跟任意的字母 数字 下划线</li></ol><p><strong>注意：</strong></p><ol><li><p>变量名不要与关键字重复</p></li><li><p>大小写敏感</p></li><li><p>变量名不允许重复定义</p></li><li><p>变量名唯一能重复出现的只有下划线</p></li></ol><p>遵循两个命名规范：</p><ol><li>Camel：骆驼命名规则：要求变量名中首字母要小写，其余每个单词的首字母都要大写，多用于给变量命名</li><li>Pascal：要求变量名中的每个单词的首字母都要大写，多用于类或方法的命名</li></ol><h1><span id="占位符">占位符</span></h1><blockquote><p>例：Console.WriteLine(“第一个数{0}，第二个数{1}，第三个数{2}”,num1,num2,num3);</p></blockquote><ul><li>填多了没效果，填少了报异常</li><li>从0开始占位</li></ul><h1><span id="转义符和的用法">转义符和@的用法</span></h1><ul><li>\n  \b  \t   </li><li>\  \r\n</li></ul><h1><span id="类型转换">类型转换</span></h1><ul><li>隐式类型转换</li><li>强制性转换</li><li>Convert转换</li></ul><h1><span id="加加减减">加加减减</span></h1><p><strong>++ ：分为前++和后++，两者的最终结果都是变量的值自身加1</strong></p><p><strong>区别：如果在一个表达式中遇到++运算符</strong></p><ul><li>如果是前++，则首先这个变量的值自身加1，然后再参与运算</li><li>如果是后++，则先参与运算，再自身加1</li></ul><p><strong>运算符总结：</strong></p><ul><li>一元运算符：++、— 、+=、-=、*=、/=、%= 只需要一个操作数就能进行运算的运算</li><li>二元运算符：+、-、*、/、%、=需要两个操作数才能进行运算的运算符</li><li>一元运算符的优先级高于二元运算符</li><li>赋值运算符  =</li><li>复合赋值运算符  += -= *= /= %=</li><li>算术运算符 + - * /</li></ul><h1><span id="关系运算符">关系运算符</span></h1><ul><li><blockquote><p>、&lt;、 &gt;= 、&lt;= 、== 、!=<br>由关系运算符连接的表达式称为关系表达式，其结果是bool类型</p></blockquote></li></ul><blockquote><p>Bool类型的结果只有两个：true、 false</p></blockquote><h1><span id="逻辑运算符">逻辑运算符</span></h1><ul><li>&amp;&amp;逻辑与    </li><li>||逻辑或   </li><li>！逻辑非</li></ul><blockquote><p>表达式1&amp;&amp;表达式2：当表达式1和表达式2全为true时，表达式的结果为true<br><br>表达式1||表达式2：当表达式1、2有一个为true时，其结果为true<br><br>！表达式：如果表达式的结果为true，则取反后为false，反之为true</p></blockquote><h1><span id="异常捕获-try-catch">异常捕获 try-catch</span></h1><p><strong>语法：</strong></p><blockquote><p>Try</p><p>{</p><p>  可能会出现异常的代码</p><p>}</p><p>Catch</p><p>{<br>    出现异常后执行的代码</p><p>}</p></blockquote><p><strong>执行过程：当try中的代码出现异常的时候，出现异常的这行代码后面的代码不会被执行</strong></p><h1><span id="注意变量的作用域">注意变量的作用域</span></h1><ul><li>作用域：能够访问到这个变量的范围</li><li>范围：一般从声明变量的那个大括号开始到这个大括号所对应的结束的大括号</li></ul><p><strong>如果想要让某些代码在满足某些条件的时候去执行，这个时候我们使用bool类型的变量来解决。</strong></p><h1><span id="switchcase">switch..case</span></h1><p><strong>作用：用来做多条件的定值判断</strong></p><p><strong>语法：</strong></p><pre><code>Switch(要判断的变量或者表达式){        Case 值1:要执行的代码；    Break;              Case 值2:要执行的代码；      Break;    Case 值3:要执行的代码；    Break;                 Default:要执行的代码；            Break;   }</code></pre><p><strong>执行过程：程序运行到switch处，首先计算switch后面所带的小括号中的变量或者表达式的值，拿着计算</strong></p><h1><span id="循环">循环</span></h1><h2><span id="ifelseifelse-ifelse">if..else/if…else if…else</span></h2><h2><span id="whiledowhile">while/do…while</span></h2><ul><li>While循环：满足条件就一直循环</li><li>do…while：至少执行一遍循环</li></ul><h2><span id="break">break</span></h2><ul><li>作用：跳出循环，只能跳出当前循环，不能跳出所有循环</li><li>一般与if连用</li></ul><h2><span id="for">for</span></h2><ul><li>快捷键：两下 tab</li><li>知道循环次数的条件下，一般使用for循环</li></ul><p><strong>语法：</strong></p><pre><code>for(表达式1;表达式2;表达式3){    循环体}</code></pre><ul><li>表达式1：一般为声明一个循环变量，用来记录循环的次数，可不写</li><li>表达式2：一般为循环的条件</li><li>表达式3：一般为能够改变循环条件的代码，可不写</li></ul><p><strong>执行过程：</strong></p><blockquote><p>在第一次循环的时候，首先执行表达式1，然后，执行表达式2，再执行循环体；<br>然后，再执行表达式3；表达式2；循环体；表达式3；表达式2；循环体；表达式3；表达式2；循环体……..直到表达式2不满足条件，跳出循环</p></blockquote><h1><span id="intparse">int.Parse</span></h1><p><code>Int.Parse(string)</code>与<code>Convert.ToInt32(string)</code>的作用一样的<br>两者转换失败都会报异常<br><code>Int.TryParse(string)</code>尝试将一个字符串转换为int类型，如果转换成功的话，返回一个true，并且将转换成功后的值赋值给一个int类型的参数，如果转换失败的话，返回一个false，并且给这个int类型的参数赋值为0。</p><h1><span id="continue">continue</span></h1><ul><li>在循环中，如果遇到break，则跳出当前循环;如果遇到continue，则立即停止本次循环，回到循环条件进行判断，如果循环条件成立，则继续执行循环，如果不成立则跳出循环</li><li>一般continue也是与if连用，单独使用没有意义</li></ul><h1><span id="三元表达式">三元表达式</span></h1><p><strong>语法：表达式1 ? 表达式2 : 表达式3;</strong></p><p><strong>表达式1一般为一个关系表达式：</strong></p><blockquote><p>如果关系表达式的结果为true，则表达式2的值就是整个三元表达式的值<br><br>如果关系表达式的结果为false，则表达式3的值就是整个三元表达式的值</p></blockquote><p><strong>注意：表达式2和表达式3的结果类型必须一致，并且也要和整个三元表达式的结果类型一致。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;net与c&quot;&gt;.net与C&lt;/span&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;.net/dotnet：一般指.Net Framework框架，一种平台，一种技术&lt;/li&gt;
&lt;li&gt;C#：一种编程语言，可以开发基于.net平台的应用&lt;br&gt;Java既是一种平台也是
      
    
    </summary>
    
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>成长之路异常艰辛</title>
    <link href="http://yoursite.com/2019/09/23/2019%E5%B9%B4%E7%9A%84%E7%9B%AE%E6%A0%87/"/>
    <id>http://yoursite.com/2019/09/23/2019年的目标/</id>
    <published>2019-09-23T11:56:33.756Z</published>
    <updated>2019-09-23T13:15:09.880Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="2019年的目标">2019年的目标</span></h1><ul><li><strong>发表一篇小论文</strong></li><li><strong>顺利毕业</strong></li><li><strong>找到一份满意的工作</strong></li><li><strong>学摄影</strong></li><li><strong>用尤克里里弹周杰伦的听妈妈的话给老妈听</strong></li><li><strong>看5本书,2本全英文</strong></li></ul><p>论文写完了，没机会发，有点可惜了。<br><br>2017年9月9日到校报到，2019年6月13日答辩完成，2019年6月21日离校，2019年6月28日收到毕业证和学位证，<strong>正式毕业</strong>。2年的研究生时光过的一点都不快乐，吃了一生都忘不了的亏，还学会熬夜，学会远离不尊重自己的人，学会做事之前要有规划，学会做事之前先尝试着自己解决，明白家人最重要。<br><br>感谢G.T.Y.T.Z.H.J.L.D…<br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;2019年的目标&quot;&gt;2019年的目标&lt;/span&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发表一篇小论文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顺利毕业&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;找到一份满意的工作&lt;/str
      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://yoursite.com/2019/08/09/Linux/"/>
    <id>http://yoursite.com/2019/08/09/Linux/</id>
    <published>2019-08-09T07:04:54.086Z</published>
    <updated>2019-09-24T00:33:25.297Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux的概述">Linux的概述</span></h1><blockquote><p>Linux是基于Unix的开源免费的操作系统，由于系统的稳定性和安全性几乎成为程序代码运行的最佳系统环境。Linux是由Linus Torvalds（林纳斯·托瓦兹）起初开发的，由于源代码的开放性，现在已经衍生出了千上百种不同的Linux系统。<br>Linux系统的应用非常广泛，不仅可以长时间的运行我们编写的程序代码，还可以安装在各种计算机硬件设备中，比如手机、平板电脑、路由器等。尤其在这里提及一下，我们熟知是Android程序最底层就是运行在linux系统上的。</p></blockquote><h1><span id="linux的分类">Linux的分类</span></h1><ul><li><p>Linux根据市场需求不同，基本分为两个方向：</p><ol><li>图形化界面版：注重用户体验，类似window操作系统，但目前成熟度不够</li><li>服务器版：没有好看的界面，是以在控制台窗口中输入命令操作系统的，类似于DOS，是我们假设服务器的最佳选择</li></ol></li><li><p>Linux根据原生程度，又分为两种：</p><ol><li>内核版本：在Linus领导下的内核小组开发维护的系统内核的版本号</li><li>发行版本：一些组织或公司在内核版基础上进行二次开发而重新发行的版本</li><li>Linux发行版本不同，又可以分为n多种：<pre><code>&gt;ubuntu&gt;CentOs&gt;redhat&gt;...</code></pre></li></ol></li></ul><h1><span id="linux的安装">Linux的安装</span></h1><h2><span id="1-虚拟机的安装">1. 虚拟机的安装</span></h2><blockquote><p>因为Linux也是一个系统，本质上跟我们电脑的Window没有区别，所以我们要学习Linux就首先将我们电脑的Window系统换成Linux系统，或者在我们电脑上安装双系统。其实我们可以在我们电脑上安装一个软件，这个软甲可以模拟一台或多台虚拟的电脑机器，这就是虚拟机。</p></blockquote><p><strong>常见的虚拟器：</strong></p><ul><li>VMware（威睿）公司的虚拟机软件，功能强大，收费</li><li>VitrualBox 虚拟机软件  Oracle公司的虚拟机软件，免费商品</li></ul><h2><span id="2-ubuntu的安装">2. Ubuntu的安装</span></h2><blockquote><p>具体步骤询问LittleSun</p></blockquote><h1><span id="linux目录结构">Linux目录结构</span></h1><h2><span id="-binbootdevetchomerootlibsbinusrvar"><strong>/———-bin/boot/dev/etc/home/root/lib/sbin/usr/var/…</strong></span></h2><p>&gt;</p><ul><li>bin(binaries)：存放二进制可执行文件</li><li>sbin(super user binaries)：存放二进制可执行文件，只有root才能访问</li><li>etc(etcetera)：存放系统配置文件   *</li><li>usr(unix shared resources)：用于存放共享的系统资源   *</li><li>home：存放用户文件的根目录   *  ——-每个用户的根目录的存放的位置，home下创建每个用户的根目录</li><li>root：超级用户文件的根目录</li><li>dev(devices)：用于存放设备文件</li><li>lib(library)：存放跟文件系统中的程序运行所需要的共享库及内核模块</li><li>mnt(mount)：系统管理员安装临时文件系统的安装点</li><li>boot：存放用于系统引导时的各种文件</li><li>tmp(temporary)：用于存放各种临时文件</li><li>var(variable)：用于存放运行时需要改变数据的文件    </li></ul><p><strong>常用命令</strong></p><blockquote><ul><li>pwd显示所在的文件夹</li><li>ls显示所在文件下的所有文件</li><li>clear 清除界面内容</li><li>cd usr 切换到该目录下的usr目录</li><li>cd ../ 切换到上一层目录</li><li>cd / 切换到系统根目录</li><li>cd ~ 切换到用户主目录</li><li>cd - 切换到上一个所在目录</li></ul></blockquote><h1><span id="目录文件夹的操作命令增删改查">目录（文件夹）的操作命令（增删改查）</span></h1><h2><span id="增加目录文件夹的操作">增加目录(文件夹)的操作</span></h2><blockquote><ul><li>mkdir 文件夹名称</li><li>mkdir 上一级目录名称 文件夹名称</li></ul></blockquote><h2><span id="查看目录">查看目录</span></h2><blockquote><ul><li>ls  ：可以看到该目录下的所有的目录和文件</li><li>ls -a ：可以看到该目录下的所有文件和目录，包括隐藏的</li><li>ls -l  ：可以看到该目录下的所有目录和文件的详细信息   ls -l 可以缩写为ll</li></ul></blockquote><h2><span id="查找目录文件夹">查找目录（文件夹）</span></h2><blockquote><ul><li>find /目录名称 参数：查找目录名称下的带“参数”相关的文件</li><li>find /root -name ‘<em>test</em>‘：在root文件夹下找名字带test的文件</li></ul></blockquote><h2><span id="移动目录的位置-剪切">移动目录的位置—-剪切</span></h2><blockquote><ul><li>mv 目录名称 目录的新位置</li><li>mv语法不仅可以对目录进行剪切操作，对文件和压缩包等也可以进行剪切操作</li></ul></blockquote><h2><span id="拷贝目录">拷贝目录</span></h2><blockquote><ul><li>cp -r 目录名称 目录拷贝的目标位置：-r表示递归，因为目录下可能有多个文件</li><li>cp命令不仅可以拷贝目录还可以拷贝文件、压缩包等，拷贝文件和压缩包时不用写-r递归</li></ul></blockquote><h2><span id="删除目录">删除目录</span></h2><blockquote><ul><li>rm [-rf] 目录</li></ul></blockquote><h1><span id="文件的操作命令增删改查">文件的操作命令（增删改查）</span></h1><h2><span id="文件的创建">文件的创建</span></h2><blockquote><ul><li>touch 文件名称 （空文件）</li></ul></blockquote><h2><span id="查看文件">查看文件</span></h2><blockquote><ul><li>cat/more/less/tail 文件</li><li>cat只能查看最后一屏</li><li>more可以显示百分比，enter可以向下一行，空格可以向下一页，q可以退出查看</li><li>less可以使用键盘上的</li><li>tail的使用：tail -10 看最后10行</li><li>tail -f：可以对某个文件进行动态监控，例如tomcat的日志文件会随着程序的运行，日志会变化，<br>可以使用tail -f catalina.log监控文件的变化</li></ul></blockquote><h2><span id="修改文件的内容">修改文件的内容</span></h2><blockquote><ul><li>vim 文件</li><li>在实际的开发中，使用vim编辑器主要的作用就是修改配置文件</li><li>操作步骤：vim 文件——-&gt;进入文件——-&gt;命令模式——-&gt;按i进入编辑模式——-&gt;编辑文件——-&gt;按Esc进入底行模式——&gt;输入:wq/q!</li><li>wq：写入并保存退出</li><li>q!：强制退出</li></ul></blockquote><h2><span id="删除文件">删除文件</span></h2><blockquote><ul><li>同目录删除：rm -rf 文件</li></ul></blockquote><h1><span id="压缩文件的操作命令">压缩文件的操作命令</span></h1><h2><span id="打包并压缩文件">打包并压缩文件</span></h2><blockquote><p>Linux中的打包文件一般是以.tar结尾的，压缩的文件一般以.gz结尾的<br>而一般打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz</p><ul><li>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</li><li>其中：z：调用gzip压缩命令进行压缩<pre><code>    c：打包文件    v：显示运行过程    f：指定文件名</code></pre></li><li>示例：打包并压缩/test下的所有文件 压缩后的压缩包指定名称为xxx.tar.gz：tar -zcvf xxx.tar.gz aaa.txt bbb.txt ccc.txt  或者  tar -zcvf xxx.tar.gz /test/*</li></ul></blockquote><h2><span id="解压压缩包">解压压缩包</span></h2><blockquote><ul><li>tar [-xvf] 压缩文件</li><li>其中：x：代表解压</li><li>示例：将/test下的xxx.tar.gz解压到当前目录下</li><li>tar -xvf xxx.tar.gz</li><li>示例：将/test下的xxx.tar.gz解压到根目录/usr下</li><li>tar -xvf xxx.tar.gz -C /usr ———-&gt;C代表指定解压的位置</li></ul></blockquote><h1><span id="其他命令">其他命令</span></h1><h2><span id="显示当前所在位置">显示当前所在位置</span></h2><blockquote><ul><li>pwd</li></ul></blockquote><h2><span id="搜索命令">搜索命令</span></h2><blockquote><ul><li>grep 要搜索的字符串 要搜索的文件</li></ul></blockquote><h2><span id="管道命令">管道命令</span></h2><blockquote><ul><li>|  将前一个命令的输出作为本次目录的输入</li><li>示例：查看当前系统中所有的进程中包括system字符串的进程<br>ps -ef | grep system</li></ul></blockquote><h2><span id="查看系统中的进程">查看系统中的进程</span></h2><blockquote><ul><li>ps -ef</li></ul></blockquote><h2><span id="杀死进程">杀死进程</span></h2><blockquote><ul><li>kill -9 进程的pid</li></ul></blockquote><h2><span id="网络通信命令">网络通信命令</span></h2><blockquote><ul><li>查看当前系统的网卡信息：ifconfig</li><li>查看与某台机器的连接情况：ping</li><li>查看当前系统的端口使用：netstat - an</li></ul></blockquote><h1><span id="linux的权限命令">Linux的权限命令</span></h1><blockquote><ul><li>权限是Linux中的重要概念，每个文件/目录等都具有权限</li><li>通过ls-l可以查看某个目录下的文件后目录的权限</li></ul><ul><li>r w x r w x r - -<br>0：文件类型  d表示文件夹 -表示文件  l表示链接（可以认为是win中的快捷方式)<br>后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的用户的权限，其他用户的权限</li></ul><ul><li><p>r：代表权限是可读，r也可以用数字4表示<br>w：代表权限是可写，w也可以用数字2表示<br>x：代表权限是可执行，x也可以用数字1表示</p></li><li><p>1：读取权<br>2：写入权——-属主权限：文件属于谁的那个权限<br>3：执行权<br>4、5、6：属组权限：同一组的权限<br>7、8、9：其他用户权限</p></li></ul></blockquote><h2><span id="修改文件目录的权限的命令">修改文件/目录的权限的命令</span></h2><blockquote><ul><li>chmod u=<strong><em>,g=</em></strong>,o=<em>*</em> 文件名</li><li>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写的权限，其他用户只有读的权限<br>chmod u=rwx,g=rw,o=r aaa.txt 或 chmod 761 aaa.txt</li></ul></blockquote><h1><span id="网络配置">网络配置</span></h1><blockquote><p>VIM命令配置<br>查看网卡配置   cat/etc/sysconfig/network-scripts/ifcfg-eth0</p></blockquote><p><strong>概要信息：</strong></p><blockquote><ul><li>DEVICE=eth0</li><li>TYPE=Ethemet</li><li>ONBOOT=yes</li><li>BOOTPROTO=static</li><li>IPADDR=192.168.44.100</li><li>GATEWAY=192.168.44.2</li><li>NETMASK=255.255.255.0</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;linux的概述&quot;&gt;Linux的概述&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Linux是基于Unix的开源免费的操作系统，由于系统的稳定性和安全性几乎成为程序代码运行的最佳系统环境。Linux是由Linus Torvalds（林纳斯·托
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git&amp;&amp;GitHub</title>
    <link href="http://yoursite.com/2019/08/09/Git&amp;GitHub/"/>
    <id>http://yoursite.com/2019/08/09/Git&amp;GitHub/</id>
    <published>2019-08-09T07:04:54.071Z</published>
    <updated>2019-09-23T07:53:42.725Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="git">Git</span></h1><p>Git是一个版本管理工具，是可以在电脑不联网的情况下，只在本地使用的一个版本管理工具，其作用就是可以更好的管理程序。</p><h1><span id="github">Github</span></h1><p>GitHub是一个网站，可以在github上建立一个网上的仓库，可以把代码提交到网上，这样别人可以看到你的代码，同时别人也可以帮你修改你的代码，这种开源的方式非常方便程序员之间的交流和学习。 </p><h1><span id="github-pages">Github Pages</span></h1><p>Github Page是Github 提供的一种免费的静态网页托管服务，可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源。</p><h1><span id="tortoisegit">TortoiseGit</span></h1><p>TortoiseGit是一个开放的GIT版本控制系统的源客户端。TortoiseGit 简称 tgit, 中文名海龟Git。海龟Git只支持神器 Windows系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;git&quot;&gt;Git&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Git是一个版本管理工具，是可以在电脑不联网的情况下，只在本地使用的一个版本管理工具，其作用就是可以更好的管理程序。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;github&quot;&gt;Github&lt;/span&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
